diff --git a/Makefile.in b/Makefile.in
index 746b38c..771c474 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.16.3 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2020 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -310,9 +310,6 @@ am__define_uniq_tagged_files = \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
-CSCOPE = cscope
 DIST_SUBDIRS = $(SUBDIRS)
 am__DIST_COMMON = $(srcdir)/Makefile.in \
 	$(top_srcdir)/build-aux/compile \
@@ -396,6 +393,8 @@ CFLAG_VISIBILITY = @CFLAG_VISIBILITY@
 CONFIG_INCLUDE = @CONFIG_INCLUDE@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
@@ -414,6 +413,7 @@ ENOLINK_VALUE = @ENOLINK_VALUE@
 EOVERFLOW_HIDDEN = @EOVERFLOW_HIDDEN@
 EOVERFLOW_VALUE = @EOVERFLOW_VALUE@
 ERRNO_H = @ERRNO_H@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 FLOAT_H = @FLOAT_H@
 GETOPT_CDEFS_H = @GETOPT_CDEFS_H@
@@ -2113,7 +2113,6 @@ cscopelist-am: $(am__tagged_files)
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 	-rm -f cscope.out cscope.in.out cscope.po.out cscope.files
-
 distdir: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
diff --git a/README b/README
index 93d1072..53b378e 100644
--- a/README
+++ b/README
@@ -1,3 +1,5 @@
+This is a fork of m4-1.4.19
+
 GNU `m4' is an implementation of the traditional Unix macro
 processor.  It is mostly SVR4 compatible, although it has some
 extensions (for example, handling more than 9 positional parameters
diff --git a/aclocal.m4 b/aclocal.m4
index 6d248d6..2d69ae7 100644
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -1,6 +1,6 @@
-# generated automatically by aclocal 1.16.3 -*- Autoconf -*-
+# generated automatically by aclocal 1.16.5 -*- Autoconf -*-
 
-# Copyright (C) 1996-2020 Free Software Foundation, Inc.
+# Copyright (C) 1996-2021 Free Software Foundation, Inc.
 
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -20,7 +20,7 @@ You have another version of autoconf.  It may work, but is not guaranteed to.
 If you have problems, you may need to regenerate the build system entirely.
 To do so, use the procedure documented by the package, typically 'autoreconf'.])])
 
-# Copyright (C) 2002-2020 Free Software Foundation, Inc.
+# Copyright (C) 2002-2021 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -35,7 +35,7 @@ AC_DEFUN([AM_AUTOMAKE_VERSION],
 [am__api_version='1.16'
 dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
 dnl require some minimum version.  Point them to the right macro.
-m4_if([$1], [1.16.3], [],
+m4_if([$1], [1.16.5], [],
       [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
 ])
 
@@ -51,14 +51,14 @@ m4_define([_AM_AUTOCONF_VERSION], [])
 # Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
 # This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-[AM_AUTOMAKE_VERSION([1.16.3])dnl
+[AM_AUTOMAKE_VERSION([1.16.5])dnl
 m4_ifndef([AC_AUTOCONF_VERSION],
   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
 _AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
 
 # AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
 
-# Copyright (C) 2001-2020 Free Software Foundation, Inc.
+# Copyright (C) 2001-2021 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -110,7 +110,7 @@ am_aux_dir=`cd "$ac_aux_dir" && pwd`
 
 # AM_CONDITIONAL                                            -*- Autoconf -*-
 
-# Copyright (C) 1997-2020 Free Software Foundation, Inc.
+# Copyright (C) 1997-2021 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -141,7 +141,7 @@ AC_CONFIG_COMMANDS_PRE(
 Usually this means the macro was only invoked conditionally.]])
 fi])])
 
-# Copyright (C) 1999-2020 Free Software Foundation, Inc.
+# Copyright (C) 1999-2021 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -332,7 +332,7 @@ _AM_SUBST_NOTMAKE([am__nodep])dnl
 
 # Generate code to set up dependency tracking.              -*- Autoconf -*-
 
-# Copyright (C) 1999-2020 Free Software Foundation, Inc.
+# Copyright (C) 1999-2021 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -400,7 +400,7 @@ AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
 
 # Do all the work for Automake.                             -*- Autoconf -*-
 
-# Copyright (C) 1996-2020 Free Software Foundation, Inc.
+# Copyright (C) 1996-2021 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -428,6 +428,10 @@ m4_defn([AC_PROG_CC])
 # release and drop the old call support.
 AC_DEFUN([AM_INIT_AUTOMAKE],
 [AC_PREREQ([2.65])dnl
+m4_ifdef([_$0_ALREADY_INIT],
+  [m4_fatal([$0 expanded multiple times
+]m4_defn([_$0_ALREADY_INIT]))],
+  [m4_define([_$0_ALREADY_INIT], m4_expansion_stack)])dnl
 dnl Autoconf wants to disallow AM_ names.  We explicitly allow
 dnl the ones we care about.
 m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl
@@ -464,7 +468,7 @@ m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl
 [_AM_SET_OPTIONS([$1])dnl
 dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.
 m4_if(
-  m4_ifdef([AC_PACKAGE_NAME], [ok]):m4_ifdef([AC_PACKAGE_VERSION], [ok]),
+  m4_ifset([AC_PACKAGE_NAME], [ok]):m4_ifset([AC_PACKAGE_VERSION], [ok]),
   [ok:ok],,
   [m4_fatal([AC_INIT should be called with package and version arguments])])dnl
  AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
@@ -516,6 +520,20 @@ AC_PROVIDE_IFELSE([AC_PROG_OBJCXX],
 		  [m4_define([AC_PROG_OBJCXX],
 			     m4_defn([AC_PROG_OBJCXX])[_AM_DEPENDENCIES([OBJCXX])])])dnl
 ])
+# Variables for tags utilities; see am/tags.am
+if test -z "$CTAGS"; then
+  CTAGS=ctags
+fi
+AC_SUBST([CTAGS])
+if test -z "$ETAGS"; then
+  ETAGS=etags
+fi
+AC_SUBST([ETAGS])
+if test -z "$CSCOPE"; then
+  CSCOPE=cscope
+fi
+AC_SUBST([CSCOPE])
+
 AC_REQUIRE([AM_SILENT_RULES])dnl
 dnl The testsuite driver may need to know about EXEEXT, so add the
 dnl 'am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This
@@ -597,7 +615,7 @@ for _am_header in $config_headers :; do
 done
 echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
 
-# Copyright (C) 2001-2020 Free Software Foundation, Inc.
+# Copyright (C) 2001-2021 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -618,7 +636,7 @@ if test x"${install_sh+set}" != xset; then
 fi
 AC_SUBST([install_sh])])
 
-# Copyright (C) 2003-2020 Free Software Foundation, Inc.
+# Copyright (C) 2003-2021 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -639,7 +657,7 @@ AC_SUBST([am__leading_dot])])
 
 # Check to see how 'make' treats includes.	            -*- Autoconf -*-
 
-# Copyright (C) 2001-2020 Free Software Foundation, Inc.
+# Copyright (C) 2001-2021 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -682,7 +700,7 @@ AC_SUBST([am__quote])])
 
 # Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
 
-# Copyright (C) 1997-2020 Free Software Foundation, Inc.
+# Copyright (C) 1997-2021 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -716,7 +734,7 @@ fi
 
 # Helper functions for option handling.                     -*- Autoconf -*-
 
-# Copyright (C) 2001-2020 Free Software Foundation, Inc.
+# Copyright (C) 2001-2021 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -745,7 +763,7 @@ AC_DEFUN([_AM_SET_OPTIONS],
 AC_DEFUN([_AM_IF_OPTION],
 [m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])
 
-# Copyright (C) 1999-2020 Free Software Foundation, Inc.
+# Copyright (C) 1999-2021 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -792,7 +810,7 @@ AC_LANG_POP([C])])
 # For backward compatibility.
 AC_DEFUN_ONCE([AM_PROG_CC_C_O], [AC_REQUIRE([AC_PROG_CC])])
 
-# Copyright (C) 2001-2020 Free Software Foundation, Inc.
+# Copyright (C) 2001-2021 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -811,7 +829,7 @@ AC_DEFUN([AM_RUN_LOG],
 
 # Check to make sure that the build environment is sane.    -*- Autoconf -*-
 
-# Copyright (C) 1996-2020 Free Software Foundation, Inc.
+# Copyright (C) 1996-2021 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -892,7 +910,7 @@ AC_CONFIG_COMMANDS_PRE(
 rm -f conftest.file
 ])
 
-# Copyright (C) 2009-2020 Free Software Foundation, Inc.
+# Copyright (C) 2009-2021 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -952,7 +970,7 @@ AC_SUBST([AM_BACKSLASH])dnl
 _AM_SUBST_NOTMAKE([AM_BACKSLASH])dnl
 ])
 
-# Copyright (C) 2001-2020 Free Software Foundation, Inc.
+# Copyright (C) 2001-2021 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -980,7 +998,7 @@ fi
 INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
 AC_SUBST([INSTALL_STRIP_PROGRAM])])
 
-# Copyright (C) 2006-2020 Free Software Foundation, Inc.
+# Copyright (C) 2006-2021 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -999,7 +1017,7 @@ AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])
 
 # Check how to create a tarball.                            -*- Autoconf -*-
 
-# Copyright (C) 2004-2020 Free Software Foundation, Inc.
+# Copyright (C) 2004-2021 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
diff --git a/checks/Makefile.in b/checks/Makefile.in
index f88bd5f..d33e527 100644
--- a/checks/Makefile.in
+++ b/checks/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.16.3 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2020 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -303,6 +303,8 @@ CFLAG_VISIBILITY = @CFLAG_VISIBILITY@
 CONFIG_INCLUDE = @CONFIG_INCLUDE@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
@@ -321,6 +323,7 @@ ENOLINK_VALUE = @ENOLINK_VALUE@
 EOVERFLOW_HIDDEN = @EOVERFLOW_HIDDEN@
 EOVERFLOW_VALUE = @EOVERFLOW_VALUE@
 ERRNO_H = @ERRNO_H@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 FLOAT_H = @FLOAT_H@
 GETOPT_CDEFS_H = @GETOPT_CDEFS_H@
@@ -1903,7 +1906,6 @@ ctags CTAGS:
 
 cscope cscopelist:
 
-
 distdir: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
diff --git a/configure b/configure
index 883336a..e0d57b8 100755
--- a/configure
+++ b/configure
@@ -2211,6 +2211,9 @@ AM_BACKSLASH
 AM_DEFAULT_VERBOSITY
 AM_DEFAULT_V
 AM_V
+CSCOPE
+ETAGS
+CTAGS
 am__untar
 am__tar
 AMTAR
@@ -5185,6 +5188,20 @@ am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'
 
 
 
+# Variables for tags utilities; see am/tags.am
+if test -z "$CTAGS"; then
+  CTAGS=ctags
+fi
+
+if test -z "$ETAGS"; then
+  ETAGS=etags
+fi
+
+if test -z "$CSCOPE"; then
+  CSCOPE=cscope
+fi
+
+
 
 # POSIX will say in a future version that running "rm -f" with no argument
 # is OK; and we want to be able to make that assumption in our Makefile
diff --git a/doc/Makefile.in b/doc/Makefile.in
index 895a780..d39994f 100644
--- a/doc/Makefile.in
+++ b/doc/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.16.3 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2020 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -378,6 +378,8 @@ CFLAG_VISIBILITY = @CFLAG_VISIBILITY@
 CONFIG_INCLUDE = @CONFIG_INCLUDE@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
@@ -396,6 +398,7 @@ ENOLINK_VALUE = @ENOLINK_VALUE@
 EOVERFLOW_HIDDEN = @EOVERFLOW_HIDDEN@
 EOVERFLOW_VALUE = @EOVERFLOW_VALUE@
 ERRNO_H = @ERRNO_H@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 FLOAT_H = @FLOAT_H@
 GETOPT_CDEFS_H = @GETOPT_CDEFS_H@
@@ -2184,7 +2187,6 @@ ctags CTAGS:
 
 cscope cscopelist:
 
-
 distdir: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
diff --git a/doc/m4.1 b/doc/m4.1
index 536f289..7d1f637 100644
--- a/doc/m4.1
+++ b/doc/m4.1
@@ -1,5 +1,5 @@
-.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.48.3.
-.TH M4 "1" "May 2021" "GNU M4 1.4.19" "User Commands"
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.1.
+.TH M4 "1" "June 2023" "GNU M4 1.4.19" "User Commands"
 .SH NAME
 m4 \- macro processor
 .SH SYNOPSIS
@@ -36,9 +36,6 @@ suppress some warnings for builtins
 warn if macro definition matches REGEXP,
 .IP
 default \e$\e({[^}]*}\e|[0\-9][0\-9]+\e)
-.TP
-\fB\-W\fR, \fB\-\-word\-regexp\fR=\fI\,REGEXP\/\fR
-use REGEXP for macro name syntax
 .SS "Preprocessor features:"
 .TP
 \fB\-D\fR, \fB\-\-define=NAME\fR[=\fI\,VALUE\/\fR]
diff --git a/examples/Makefile.in b/examples/Makefile.in
index 7c2ce85..87b1baa 100644
--- a/examples/Makefile.in
+++ b/examples/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.16.3 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2020 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -303,6 +303,8 @@ CFLAG_VISIBILITY = @CFLAG_VISIBILITY@
 CONFIG_INCLUDE = @CONFIG_INCLUDE@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
@@ -321,6 +323,7 @@ ENOLINK_VALUE = @ENOLINK_VALUE@
 EOVERFLOW_HIDDEN = @EOVERFLOW_HIDDEN@
 EOVERFLOW_VALUE = @EOVERFLOW_VALUE@
 ERRNO_H = @ERRNO_H@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 FLOAT_H = @FLOAT_H@
 GETOPT_CDEFS_H = @GETOPT_CDEFS_H@
@@ -1945,7 +1948,6 @@ ctags CTAGS:
 
 cscope cscopelist:
 
-
 distdir: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
diff --git a/lib/Makefile.in b/lib/Makefile.in
index 392435e..382f217 100644
--- a/lib/Makefile.in
+++ b/lib/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.16.3 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2020 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -656,8 +656,6 @@ am__define_uniq_tagged_files = \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
 am__DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/config.hin \
 	$(srcdir)/gnulib.mk $(top_srcdir)/build-aux/depcomp
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
@@ -687,6 +685,8 @@ CFLAG_VISIBILITY = @CFLAG_VISIBILITY@
 CONFIG_INCLUDE = @CONFIG_INCLUDE@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
@@ -705,6 +705,7 @@ ENOLINK_VALUE = @ENOLINK_VALUE@
 EOVERFLOW_HIDDEN = @EOVERFLOW_HIDDEN@
 EOVERFLOW_VALUE = @EOVERFLOW_VALUE@
 ERRNO_H = @ERRNO_H@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 FLOAT_H = @FLOAT_H@
 GETOPT_CDEFS_H = @GETOPT_CDEFS_H@
@@ -2929,7 +2930,6 @@ cscopelist-am: $(am__tagged_files)
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-
 distdir: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
diff --git a/lib/hash-triple-simple.c b/lib/hash-triple-simple.c
index f382538..ea9cc4b 100644
--- a/lib/hash-triple-simple.c
+++ b/lib/hash-triple-simple.c
@@ -27,7 +27,7 @@
 #include "hash-pjw.h"
 #include "same-inode.h"
 
-#define STREQ(a, b) (strcmp (a, b) == 0)
+static int STREQ(const char *a, const char *b) { return (strcmp(a, b) == 0); }
 
 /* Hash an F_triple, and *do* consider the file name.  */
 size_t
diff --git a/src/Makefile.in b/src/Makefile.in
index cb54a3e..8ece60f 100644
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.16.3 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2020 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -333,8 +333,6 @@ am__define_uniq_tagged_files = \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
 am__DIST_COMMON = $(srcdir)/Makefile.in \
 	$(top_srcdir)/build-aux/depcomp
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
@@ -364,6 +362,8 @@ CFLAG_VISIBILITY = @CFLAG_VISIBILITY@
 CONFIG_INCLUDE = @CONFIG_INCLUDE@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
@@ -382,6 +382,7 @@ ENOLINK_VALUE = @ENOLINK_VALUE@
 EOVERFLOW_HIDDEN = @EOVERFLOW_HIDDEN@
 EOVERFLOW_VALUE = @EOVERFLOW_VALUE@
 ERRNO_H = @ERRNO_H@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 FLOAT_H = @FLOAT_H@
 GETOPT_CDEFS_H = @GETOPT_CDEFS_H@
@@ -2105,7 +2106,6 @@ cscopelist-am: $(am__tagged_files)
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-
 distdir: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
diff --git a/src/builtin.c b/src/builtin.c
index 5e36ab3..7cc52bd 100644
--- a/src/builtin.c
+++ b/src/builtin.c
@@ -31,64 +31,64 @@
 #include "spawn-pipe.h"
 #include "wait-process.h"
 
-#define ARG(i) (argc > (i) ? TOKEN_DATA_TEXT (argv[i]) : "")
+static char *ARG(int i, int argc, token_data **argv) {
+  return (argc > (i) ? *TOKEN_DATA_TEXT(argv[i]) : "");
+}
+
 
 /* Initialization of builtin and predefined macros.  The table
    "builtin_tab" is both used for initialization, and by the "builtin"
    builtin.  */
 
-#define DECLARE(name) \
-  static void name (struct obstack *, int, token_data **)
+typedef void(m4_declare)(struct obstack *, int, token_data **);
 
-DECLARE (m4___file__);
-DECLARE (m4___line__);
-DECLARE (m4___program__);
-DECLARE (m4_builtin);
-DECLARE (m4_changecom);
-DECLARE (m4_changequote);
+static m4_declare m4___file__;
+static m4_declare m4___line__;
+static m4_declare m4___program__;
+static m4_declare m4_builtin;
+static m4_declare m4_changecom;
+static m4_declare m4_changequote;
 #ifdef ENABLE_CHANGEWORD
-DECLARE (m4_changeword);
+static m4_declare m4_changeword;
 #endif
-DECLARE (m4_debugmode);
-DECLARE (m4_debugfile);
-DECLARE (m4_decr);
-DECLARE (m4_define);
-DECLARE (m4_defn);
-DECLARE (m4_divert);
-DECLARE (m4_divnum);
-DECLARE (m4_dnl);
-DECLARE (m4_dumpdef);
-DECLARE (m4_errprint);
-DECLARE (m4_esyscmd);
-DECLARE (m4_eval);
-DECLARE (m4_format);
-DECLARE (m4_ifdef);
-DECLARE (m4_ifelse);
-DECLARE (m4_include);
-DECLARE (m4_incr);
-DECLARE (m4_index);
-DECLARE (m4_indir);
-DECLARE (m4_len);
-DECLARE (m4_m4exit);
-DECLARE (m4_m4wrap);
-DECLARE (m4_maketemp);
-DECLARE (m4_mkstemp);
-DECLARE (m4_patsubst);
-DECLARE (m4_popdef);
-DECLARE (m4_pushdef);
-DECLARE (m4_regexp);
-DECLARE (m4_shift);
-DECLARE (m4_sinclude);
-DECLARE (m4_substr);
-DECLARE (m4_syscmd);
-DECLARE (m4_sysval);
-DECLARE (m4_traceoff);
-DECLARE (m4_traceon);
-DECLARE (m4_translit);
-DECLARE (m4_undefine);
-DECLARE (m4_undivert);
-
-#undef DECLARE
+static m4_declare m4_debugmode;
+static m4_declare m4_debugfile;
+static m4_declare m4_decr;
+static m4_declare m4_define;
+static m4_declare m4_defn;
+static m4_declare m4_divert;
+static m4_declare m4_divnum;
+static m4_declare m4_dnl;
+static m4_declare m4_dumpdef;
+static m4_declare m4_errprint;
+static m4_declare m4_esyscmd;
+static m4_declare m4_eval;
+static m4_declare m4_format;
+static m4_declare m4_ifdef;
+static m4_declare m4_ifelse;
+static m4_declare m4_include;
+static m4_declare m4_incr;
+static m4_declare m4_index;
+static m4_declare m4_indir;
+static m4_declare m4_len;
+static m4_declare m4_m4exit;
+static m4_declare m4_m4wrap;
+static m4_declare m4_maketemp;
+static m4_declare m4_mkstemp;
+static m4_declare m4_patsubst;
+static m4_declare m4_popdef;
+static m4_declare m4_pushdef;
+static m4_declare m4_regexp;
+static m4_declare m4_shift;
+static m4_declare m4_sinclude;
+static m4_declare m4_substr;
+static m4_declare m4_syscmd;
+static m4_declare m4_sysval;
+static m4_declare m4_traceoff;
+static m4_declare m4_traceon;
+static m4_declare m4_translit;
+static m4_declare m4_undefine;
+static m4_declare m4_undivert;
 
 static builtin const builtin_tab[] =
 {
@@ -151,24 +151,6 @@ static builtin const builtin_tab[] =
   { "placeholder",      true,   false,  false,  m4_placeholder },
 };
 
-static predefined const predefined_tab[] =
-{
-#if UNIX
-  { "unix",     "__unix__",     "" },
-#endif
-#if W32_NATIVE
-  { "windows",  "__windows__",  "" },
-#endif
-#if OS2
-  { "os2",      "__os2__",      "" },
-#endif
-#if !UNIX && !W32_NATIVE && !OS2
-# warning Platform macro not provided
-#endif
-  { NULL,       "__gnu__",      "" },
-
-  { NULL,       NULL,           NULL },
-};
 
 /*----------------------------------------.
 | Find the builtin, which lives on ADDR.  |
@@ -214,10 +196,10 @@ define_builtin (const char *name, const builtin *bp, symbol_lookup mode)
   symbol *sym;
 
   sym = lookup_symbol (name, mode);
-  SYMBOL_TYPE (sym) = TOKEN_FUNC;
-  SYMBOL_MACRO_ARGS (sym) = bp->groks_macro_args;
-  SYMBOL_BLIND_NO_ARGS (sym) = bp->blind_if_no_args;
-  SYMBOL_FUNC (sym) = bp->func;
+  *SYMBOL_TYPE (sym) = TOKEN_FUNC;
+  SYMBOL_MACRO_ARGS_set(sym, bp->groks_macro_args);
+  SYMBOL_BLIND_NO_ARGS_set(sym, bp->blind_if_no_args);
+  *SYMBOL_FUNC (sym) = bp->func;
 }
 
 /* Storage for the compiled regular expression of
@@ -292,11 +274,11 @@ define_user_macro (const char *name, const char *text, symbol_lookup mode)
   char *defn = xstrdup (text ? text : "");
 
   s = lookup_symbol (name, mode);
-  if (SYMBOL_TYPE (s) == TOKEN_TEXT)
-    free (SYMBOL_TEXT (s));
+  if (*SYMBOL_TYPE (s) == TOKEN_TEXT)
+    free (*SYMBOL_TEXT (s));
 
-  SYMBOL_TYPE (s) = TOKEN_TEXT;
-  SYMBOL_TEXT (s) = defn;
+  *SYMBOL_TYPE (s) = TOKEN_TEXT;
+  *SYMBOL_TEXT (s) = defn;
 
   /* Implement --warn-macro-sequence.  */
   if (macro_sequence_inuse && text)
@@ -316,16 +298,16 @@ define_user_macro (const char *name, const char *text, symbol_lookup mode)
               offset = macro_sequence_regs.end[0];
               tmp = defn[offset];
               defn[offset] = '\0';
-              M4ERROR ((warning_status, 0,
+              M4ERROR(warning_status, 0,
                         _("Warning: definition of `%s' contains sequence `%s'"),
-                        name, defn + macro_sequence_regs.start[0]));
+                        name, defn + macro_sequence_regs.start[0]);
               defn[offset] = tmp;
             }
         }
       if (offset == -2)
-        M4ERROR ((warning_status, 0,
+        M4ERROR(warning_status, 0,
                   _("error checking --warn-macro-sequence for macro `%s'"),
-                  name));
+                  name);
     }
 }
 
@@ -337,7 +319,6 @@ void
 builtin_init (void)
 {
   const builtin *bp;
-  const predefined *pp;
   char *string;
 
   for (bp = &builtin_tab[0]; bp->name != NULL; bp++)
@@ -355,17 +336,19 @@ builtin_init (void)
           define_builtin (bp->name, bp, SYMBOL_INSERT);
       }
 
-  for (pp = &predefined_tab[0]; pp->func != NULL; pp++)
-    if (no_gnu_extensions)
-      {
-        if (pp->unix_name != NULL)
-          define_user_macro (pp->unix_name, pp->func, SYMBOL_INSERT);
-      }
-    else
-      {
-        if (pp->gnu_name != NULL)
-          define_user_macro (pp->gnu_name, pp->func, SYMBOL_INSERT);
-      }
+  if (!UNIX && !W32_NATIVE && !OS2)
+    perror("Platform macro not provided");
+
+  if (no_gnu_extensions) {
+    if (UNIX) define_user_macro("unix", "", SYMBOL_INSERT);
+    if (W32_NATIVE) define_user_macro("windows", "", SYMBOL_INSERT);
+    if (OS2) define_user_macro("os2", "", SYMBOL_INSERT);
+  } else {
+    if (UNIX) define_user_macro("__unix__", "", SYMBOL_INSERT);
+    if (W32_NATIVE) define_user_macro("__windows__", "", SYMBOL_INSERT);
+    if (OS2) define_user_macro("__os2__", "", SYMBOL_INSERT);
+    define_user_macro("__gnu__", "", SYMBOL_INSERT);
+  }
 }
 
 /*-------------------------------------------------------------------.
@@ -384,15 +367,15 @@ bad_argc (token_data *name, int argc, int min, int max)
   if (min > 0 && argc < min)
     {
       if (!suppress_warnings)
-        M4ERROR ((warning_status, 0,
+        M4ERROR(warning_status, 0,
                   _("Warning: too few arguments to builtin `%s'"),
-                  TOKEN_DATA_TEXT (name)));
+                  *TOKEN_DATA_TEXT (name));
       isbad = true;
     }
   else if (max > 0 && argc > max && !suppress_warnings)
-    M4ERROR ((warning_status, 0,
+    M4ERROR(warning_status, 0,
               _("Warning: excess arguments to builtin `%s' ignored"),
-              TOKEN_DATA_TEXT (name)));
+              *TOKEN_DATA_TEXT (name));
 
   return isbad;
 }
@@ -411,9 +394,9 @@ numeric_arg (token_data *macro, const char *arg, int *valuep)
   if (*arg == '\0')
     {
       *valuep = 0;
-      M4ERROR ((warning_status, 0,
+      M4ERROR(warning_status, 0,
                 _("empty string treated as 0 in builtin `%s'"),
-                TOKEN_DATA_TEXT (macro)));
+                *TOKEN_DATA_TEXT (macro));
     }
   else
     {
@@ -421,19 +404,19 @@ numeric_arg (token_data *macro, const char *arg, int *valuep)
       *valuep = strtol (arg, &endp, 10);
       if (*endp != '\0')
         {
-          M4ERROR ((warning_status, 0,
+          M4ERROR(warning_status, 0,
                     _("non-numeric argument to builtin `%s'"),
-                    TOKEN_DATA_TEXT (macro)));
+                    *TOKEN_DATA_TEXT (macro));
           return false;
         }
       if (c_isspace (*arg))
-        M4ERROR ((warning_status, 0,
+        M4ERROR(warning_status, 0,
                   _("leading whitespace ignored in builtin `%s'"),
-                  TOKEN_DATA_TEXT (macro)));
+                  *TOKEN_DATA_TEXT (macro));
       else if (errno == ERANGE)
-        M4ERROR ((warning_status, 0,
+        M4ERROR(warning_status, 0,
                   _("numeric overflow detected in builtin `%s'"),
-                  TOKEN_DATA_TEXT (macro)));
+                  *TOKEN_DATA_TEXT (macro));
     }
   return true;
 }
@@ -511,8 +494,8 @@ dump_args (struct obstack *obs, int argc, token_data **argv,
         obstack_grow (obs, sep, len);
       if (quoted)
         obstack_grow (obs, lquote.string, lquote.length);
-      obstack_grow (obs, TOKEN_DATA_TEXT (argv[i]),
-                    strlen (TOKEN_DATA_TEXT (argv[i])));
+      obstack_grow (obs, *TOKEN_DATA_TEXT (argv[i]),
+                    strlen (*TOKEN_DATA_TEXT (argv[i])));
       if (quoted)
         obstack_grow (obs, rquote.string, rquote.length);
     }
@@ -546,37 +529,37 @@ define_macro (int argc, token_data **argv, symbol_lookup mode)
   if (bad_argc (argv[0], argc, 2, 3))
     return;
 
-  if (TOKEN_DATA_TYPE (argv[1]) != TOKEN_TEXT)
+  if (*TOKEN_DATA_TYPE (argv[1]) != TOKEN_TEXT)
     {
-      M4ERROR ((warning_status, 0,
-                _("Warning: %s: invalid macro name ignored"), ARG (0)));
+      M4ERROR(warning_status, 0,
+                _("Warning: %s: invalid macro name ignored"), ARG (0, argc, argv));
       return;
     }
 
   if (argc == 2)
     {
-      define_user_macro (ARG (1), "", mode);
+      define_user_macro (ARG (1, argc, argv), "", mode);
       return;
     }
 
-  switch (TOKEN_DATA_TYPE (argv[2]))
+  switch (*TOKEN_DATA_TYPE (argv[2]))
     {
     case TOKEN_TEXT:
-      define_user_macro (ARG (1), ARG (2), mode);
+      define_user_macro (ARG (1, argc, argv), ARG (2, argc, argv), mode);
       break;
 
     case TOKEN_FUNC:
-      bp = find_builtin_by_addr (TOKEN_DATA_FUNC (argv[2]));
+      bp = find_builtin_by_addr (*TOKEN_DATA_FUNC (argv[2]));
       if (bp == NULL)
         return;
       else
-        define_builtin (ARG (1), bp, mode);
+        define_builtin (ARG (1, argc, argv), bp, mode);
       break;
 
     case TOKEN_VOID:
     default:
-      M4ERROR ((warning_status, 0,
-                "INTERNAL ERROR: bad token data type in define_macro ()"));
+      M4ERROR(warning_status, 0,
+                "INTERNAL ERROR: bad token data type in define_macro ()");
       abort ();
     }
 }
@@ -594,7 +577,7 @@ m4_undefine (struct obstack *obs MAYBE_UNUSED, int argc, token_data **argv)
   if (bad_argc (argv[0], argc, 2, -1))
     return;
   for (i = 1; i < argc; i++)
-    lookup_symbol (ARG (i), SYMBOL_DELETE);
+    lookup_symbol (ARG (i, argc, argv), SYMBOL_DELETE);
 }
 
 static void
@@ -610,7 +593,7 @@ m4_popdef (struct obstack *obs MAYBE_UNUSED, int argc, token_data **argv)
   if (bad_argc (argv[0], argc, 2, -1))
     return;
   for (i = 1; i < argc; i++)
-    lookup_symbol (ARG (i), SYMBOL_POPDEF);
+    lookup_symbol (ARG (i, argc, argv), SYMBOL_POPDEF);
 }
 
 /*---------------------.
@@ -625,12 +608,12 @@ m4_ifdef (struct obstack *obs, int argc, token_data **argv)
 
   if (bad_argc (argv[0], argc, 3, 4))
     return;
-  s = lookup_symbol (ARG (1), SYMBOL_LOOKUP);
+  s = lookup_symbol (ARG (1, argc, argv), SYMBOL_LOOKUP);
 
-  if (s != NULL && SYMBOL_TYPE (s) != TOKEN_VOID)
-    result = ARG (2);
+  if (s != NULL && *SYMBOL_TYPE (s) != TOKEN_VOID)
+    result = ARG (2, argc, argv);
   else if (argc >= 4)
-    result = ARG (3);
+    result = ARG (3, argc, argv);
   else
     result = NULL;
 
@@ -659,8 +642,8 @@ m4_ifelse (struct obstack *obs, int argc, token_data **argv)
   result = NULL;
   while (result == NULL)
 
-    if (STREQ (ARG (0), ARG (1)))
-      result = ARG (2);
+    if (STREQ (ARG (0, argc, argv), ARG (1, argc, argv)))
+      result = ARG (2, argc, argv);
 
     else
       switch (argc)
@@ -670,7 +653,7 @@ m4_ifelse (struct obstack *obs, int argc, token_data **argv)
 
         case 4:
         case 5:
-          result = ARG (3);
+          result = ARG (3, argc, argv);
           break;
 
         default:
@@ -700,7 +683,7 @@ static void
 dump_symbol (symbol *sym, void *arg)
 {
   struct dump_symbol_data *data = (struct dump_symbol_data *) arg;
-  if (SYMBOL_TYPE (sym) != TOKEN_VOID)
+  if (*SYMBOL_TYPE (sym) != TOKEN_VOID)
     {
       obstack_blank (data->obs, sizeof (symbol *));
       data->base = (symbol **) obstack_base (data->obs);
@@ -715,8 +698,8 @@ dump_symbol (symbol *sym, void *arg)
 static int
 dumpdef_cmp (const void *s1, const void *s2)
 {
-  return strcmp (SYMBOL_NAME (* (symbol *const *) s1),
-                 SYMBOL_NAME (* (symbol *const *) s2));
+  return strcmp (*SYMBOL_NAME (* (symbol *const *) s1),
+                 *SYMBOL_NAME (* (symbol *const *) s2));
 }
 
 /*-------------------------------------------------------------.
@@ -744,12 +727,12 @@ m4_dumpdef (struct obstack *obs, int argc, token_data **argv)
     {
       for (i = 1; i < argc; i++)
         {
-          s = lookup_symbol (TOKEN_DATA_TEXT (argv[i]), SYMBOL_LOOKUP);
-          if (s != NULL && SYMBOL_TYPE (s) != TOKEN_VOID)
+          s = lookup_symbol (*TOKEN_DATA_TEXT (argv[i]), SYMBOL_LOOKUP);
+          if (s != NULL && *SYMBOL_TYPE (s) != TOKEN_VOID)
             dump_symbol (s, &data);
           else
-            M4ERROR ((warning_status, 0,
-                      _("undefined macro `%s'"), TOKEN_DATA_TEXT (argv[i])));
+            M4ERROR(warning_status, 0,
+                      _("undefined macro `%s'"), *TOKEN_DATA_TEXT (argv[i]));
         }
     }
 
@@ -761,33 +744,33 @@ m4_dumpdef (struct obstack *obs, int argc, token_data **argv)
 
   for (; data.size > 0; --data.size, data.base++)
     {
-      DEBUG_PRINT1 ("%s:\t", SYMBOL_NAME (data.base[0]));
+      DEBUG_PRINT1 ("%s:\t", *SYMBOL_NAME (data.base[0]));
 
-      switch (SYMBOL_TYPE (data.base[0]))
+      switch (*SYMBOL_TYPE (data.base[0]))
         {
         case TOKEN_TEXT:
           if (debug_level & DEBUG_TRACE_QUOTE)
             DEBUG_PRINT3 ("%s%s%s\n",
-                          lquote.string, SYMBOL_TEXT (data.base[0]), rquote.string);
+                          lquote.string, *SYMBOL_TEXT (data.base[0]), rquote.string);
           else
-            DEBUG_PRINT1 ("%s\n", SYMBOL_TEXT (data.base[0]));
+            DEBUG_PRINT1 ("%s\n", *SYMBOL_TEXT (data.base[0]));
           break;
 
         case TOKEN_FUNC:
-          bp = find_builtin_by_addr (SYMBOL_FUNC (data.base[0]));
+          bp = find_builtin_by_addr (*SYMBOL_FUNC (data.base[0]));
           if (bp == NULL)
             {
-              M4ERROR ((warning_status, 0, "\
-INTERNAL ERROR: builtin not found in builtin table"));
+              M4ERROR(warning_status, 0, "\
+INTERNAL ERROR: builtin not found in builtin table");
               abort ();
             }
-          DEBUG_PRINT1 ("<%s>\n", bp->name);
+          DEBUG_PRINT1_const("<%s>\n", bp->name);
           break;
 
         case TOKEN_VOID:
         default:
-          M4ERROR ((warning_status, 0,
-                    "INTERNAL ERROR: bad token data type in m4_dumpdef ()"));
+          M4ERROR(warning_status, 0,
+                    "INTERNAL ERROR: bad token data type in m4_dumpdef ()");
           abort ();
           break;
         }
@@ -809,27 +792,27 @@ m4_builtin (struct obstack *obs, int argc, token_data **argv)
 
   if (bad_argc (argv[0], argc, 2, -1))
     return;
-  if (TOKEN_DATA_TYPE (argv[1]) != TOKEN_TEXT)
+  if (*TOKEN_DATA_TYPE (argv[1]) != TOKEN_TEXT)
     {
-      M4ERROR ((warning_status, 0,
-                _("Warning: %s: invalid macro name ignored"), ARG (0)));
+      M4ERROR(warning_status, 0,
+                _("Warning: %s: invalid macro name ignored"), ARG (0, argc, argv));
       return;
     }
 
-  name = ARG (1);
+  name = ARG (1, argc, argv);
   bp = find_builtin_by_name (name);
   if (bp->func == m4_placeholder)
-    M4ERROR ((warning_status, 0,
-              _("undefined builtin `%s'"), name));
+    M4ERROR(warning_status, 0,
+              _("undefined builtin `%s'"), name);
   else
     {
       int i;
       if (! bp->groks_macro_args)
         for (i = 2; i < argc; i++)
-          if (TOKEN_DATA_TYPE (argv[i]) != TOKEN_TEXT)
+          if (*TOKEN_DATA_TYPE (argv[i]) != TOKEN_TEXT)
             {
-              TOKEN_DATA_TYPE (argv[i]) = TOKEN_TEXT;
-              TOKEN_DATA_TEXT (argv[i]) = (char *) "";
+              *TOKEN_DATA_TYPE (argv[i]) = TOKEN_TEXT;
+              *TOKEN_DATA_TEXT (argv[i]) = (char *) "";
             }
       bp->func (obs, argc - 1, argv + 1);
     }
@@ -850,27 +833,27 @@ m4_indir (struct obstack *obs, int argc, token_data **argv)
 
   if (bad_argc (argv[0], argc, 2, -1))
     return;
-  if (TOKEN_DATA_TYPE (argv[1]) != TOKEN_TEXT)
+  if (*TOKEN_DATA_TYPE (argv[1]) != TOKEN_TEXT)
     {
-      M4ERROR ((warning_status, 0,
-                _("Warning: %s: invalid macro name ignored"), ARG (0)));
+      M4ERROR(warning_status, 0,
+                _("Warning: %s: invalid macro name ignored"), ARG (0, argc, argv));
       return;
     }
 
-  name = ARG (1);
+  name = ARG (1, argc, argv);
   s = lookup_symbol (name, SYMBOL_LOOKUP);
-  if (s == NULL || SYMBOL_TYPE (s) == TOKEN_VOID)
-    M4ERROR ((warning_status, 0,
-              _("undefined macro `%s'"), name));
+  if (s == NULL || *SYMBOL_TYPE (s) == TOKEN_VOID)
+    M4ERROR(warning_status, 0,
+              _("undefined macro `%s'"), name);
   else
     {
       int i;
-      if (! SYMBOL_MACRO_ARGS (s))
+      if (! SYMBOL_MACRO_ARGS_get(s))
         for (i = 2; i < argc; i++)
-          if (TOKEN_DATA_TYPE (argv[i]) != TOKEN_TEXT)
+          if (*TOKEN_DATA_TYPE (argv[i]) != TOKEN_TEXT)
             {
-              TOKEN_DATA_TYPE (argv[i]) = TOKEN_TEXT;
-              TOKEN_DATA_TEXT (argv[i]) = (char *) "";
+              *TOKEN_DATA_TYPE (argv[i]) = TOKEN_TEXT;
+              *TOKEN_DATA_TEXT (argv[i]) = (char *) "";
             }
       call_macro (s, argc - 1, argv + 1, obs);
     }
@@ -895,28 +878,28 @@ m4_defn (struct obstack *obs, int argc, token_data **argv)
   assert (0 < argc);
   for (i = 1; i < (unsigned) argc; i++)
     {
-      const char *arg = ARG((int) i);
+      const char *arg = ARG ((int) i, argc, argv);
       s = lookup_symbol (arg, SYMBOL_LOOKUP);
       if (s == NULL)
         continue;
 
-      switch (SYMBOL_TYPE (s))
+      switch (*SYMBOL_TYPE (s))
         {
         case TOKEN_TEXT:
           obstack_grow (obs, lquote.string, lquote.length);
-          obstack_grow (obs, SYMBOL_TEXT (s), strlen (SYMBOL_TEXT (s)));
+          obstack_grow (obs, *SYMBOL_TEXT (s), strlen (*SYMBOL_TEXT (s)));
           obstack_grow (obs, rquote.string, rquote.length);
           break;
 
         case TOKEN_FUNC:
-          b = SYMBOL_FUNC (s);
+          b = *SYMBOL_FUNC (s);
           if (b == m4_placeholder)
-            M4ERROR ((warning_status, 0, _("\
-builtin `%s' requested by frozen file is not supported"), arg));
+            M4ERROR(warning_status, 0, _("\
+builtin `%s' requested by frozen file is not supported"), arg);
           else if (argc != 2)
-            M4ERROR ((warning_status, 0,
+            M4ERROR(warning_status, 0,
                       _("Warning: cannot concatenate builtin `%s'"),
-                      arg));
+                      arg);
           else
             push_macro (b);
           break;
@@ -926,8 +909,8 @@ builtin `%s' requested by frozen file is not supported"), arg));
           break;
 
         default:
-          M4ERROR ((warning_status, 0,
-                    "INTERNAL ERROR: bad symbol type in m4_defn ()"));
+          M4ERROR(warning_status, 0,
+                    "INTERNAL ERROR: bad symbol type in m4_defn ()");
           abort ();
         }
     }
@@ -944,7 +927,7 @@ static int sysval;
 static void
 m4_syscmd (struct obstack *obs MAYBE_UNUSED, int argc, token_data **argv)
 {
-  const char *cmd = ARG (1);
+  const char *cmd = ARG (1, argc, argv);
   int status;
   int sig_status;
   const char *prog_args[4] = { "sh", "-c" };
@@ -956,16 +939,16 @@ m4_syscmd (struct obstack *obs MAYBE_UNUSED, int argc, token_data **argv)
     }
 
   debug_flush_files ();
-#if W32_NATIVE
-  if (strstr (SYSCMD_SHELL, "cmd"))
+  if (W32_NATIVE) {
+    if (strstr(SYSCMD_SHELL, "cmd"))
     {
       prog_args[0] = "cmd";
       prog_args[1] = "/c";
     }
-#endif
+  }
   prog_args[2] = cmd;
   errno = 0;
-  status = execute (ARG (0), SYSCMD_SHELL, prog_args, NULL, false,
+  status = execute (ARG (0, argc, argv), SYSCMD_SHELL, prog_args, NULL, false,
                     false, false, false, true, false, &sig_status);
   if (sig_status)
     {
@@ -975,7 +958,7 @@ m4_syscmd (struct obstack *obs MAYBE_UNUSED, int argc, token_data **argv)
   else
     {
       if (status == 127 && errno)
-        M4ERROR ((warning_status, errno, _("cannot run command `%s'"), cmd));
+        M4ERROR(warning_status, errno, _("cannot run command `%s'"), cmd);
       sysval = status;
     }
 }
@@ -983,7 +966,7 @@ m4_syscmd (struct obstack *obs MAYBE_UNUSED, int argc, token_data **argv)
 static void
 m4_esyscmd (struct obstack *obs, int argc, token_data **argv)
 {
-  const char *cmd = ARG (1);
+  const char *cmd = ARG (1, argc, argv);
   const char *prog_args[4] = { "sh", "-c" };
   pid_t child;
   int fd;
@@ -999,33 +982,33 @@ m4_esyscmd (struct obstack *obs, int argc, token_data **argv)
     }
 
   debug_flush_files ();
-#if W32_NATIVE
-  if (strstr (SYSCMD_SHELL, "cmd"))
+  if (W32_NATIVE) {
+    if (strstr(SYSCMD_SHELL, "cmd"))
     {
       prog_args[0] = "cmd";
       prog_args[1] = "/c";
     }
-#endif
+  }
   prog_args[2] = cmd;
   errno = 0;
-  child = create_pipe_in (ARG (0), SYSCMD_SHELL, prog_args, NULL,
+  child = create_pipe_in (ARG (0, argc, argv), SYSCMD_SHELL, prog_args, NULL,
                           NULL, false, true, false, &fd);
   if (child == -1)
     {
-      M4ERROR ((warning_status, errno, _("cannot run command `%s'"), cmd));
+      M4ERROR(warning_status, errno, _("cannot run command `%s'"), cmd);
       sysval = 127;
       return;
     }
-#if OS2
-  /* On OS/2 kLIBC, fdopen() creates a stream in a mode of a file descriptor.
-     So include "t" to open a stream in a text mode explicitly on OS/2. */
-  pin = fdopen (fd, "rt");
-#else
-  pin = fdopen (fd, "r");
-#endif
+  if (OS2) {
+    /* On OS/2 kLIBC, fdopen() creates a stream in a mode of a file descriptor.
+       So include "t" to open a stream in a text mode explicitly on OS/2. */
+    pin = fdopen(fd, "rt");
+  } else {
+    pin = fdopen(fd, "r");
+  }
   if (pin == NULL)
     {
-      M4ERROR ((warning_status, errno, _("cannot run command `%s'"), cmd));
+      M4ERROR(warning_status, errno, _("cannot run command `%s'"), cmd);
       sysval = 127;
       close (fd);
       return;
@@ -1050,7 +1033,7 @@ m4_esyscmd (struct obstack *obs, int argc, token_data **argv)
   if (ferror (pin) || fclose (pin))
     m4_failure (errno, _("cannot read pipe"));
   errno = 0;
-  status = wait_subprocess (child, ARG (0), false, true, true, false,
+  status = wait_subprocess (child, ARG (0, argc, argv), false, true, true, false,
                             &sig_status);
   if (sig_status)
     {
@@ -1060,7 +1043,7 @@ m4_esyscmd (struct obstack *obs, int argc, token_data **argv)
   else
     {
       if (status == 127 && errno)
-        M4ERROR ((warning_status, errno, _("cannot run command `%s'"), cmd));
+        M4ERROR(warning_status, errno, _("cannot run command `%s'"), cmd);
       sysval = status;
     }
 }
@@ -1089,30 +1072,30 @@ m4_eval (struct obstack *obs, int argc, token_data **argv)
   if (bad_argc (argv[0], argc, 2, 4))
     return;
 
-  if (*ARG (2) && !numeric_arg (argv[0], ARG (2), &radix))
+  if (*ARG (2, argc, argv) && !numeric_arg (argv[0], ARG (2, argc, argv), &radix))
     return;
 
   if (radix < 1 || radix > (int) strlen (digits))
     {
-      M4ERROR ((warning_status, 0,
+      M4ERROR(warning_status, 0,
                 _("radix %d in builtin `%s' out of range"),
-                radix, ARG (0)));
+                radix, ARG (0, argc, argv));
       return;
     }
 
-  if (argc >= 4 && !numeric_arg (argv[0], ARG (3), &min))
+  if (argc >= 4 && !numeric_arg (argv[0], ARG (3, argc, argv), &min))
     return;
   if (min < 0)
     {
-      M4ERROR ((warning_status, 0,
-                _("negative width to builtin `%s'"), ARG (0)));
+      M4ERROR(warning_status, 0,
+                _("negative width to builtin `%s'"), ARG (0, argc, argv));
       return;
     }
 
-  if (!*ARG (1))
-    M4ERROR ((warning_status, 0,
-              _("empty string treated as 0 in builtin `%s'"), ARG (0)));
-  else if (evaluate (ARG (1), &value))
+  if (!*ARG (1, argc, argv))
+    M4ERROR(warning_status, 0,
+              _("empty string treated as 0 in builtin `%s'"), ARG (0, argc, argv));
+  else if (evaluate (ARG (1, argc, argv), &value))
     return;
 
   if (radix == 1)
@@ -1152,7 +1135,7 @@ m4_incr (struct obstack *obs, int argc, token_data **argv)
   if (bad_argc (argv[0], argc, 2, 2))
     return;
 
-  if (!numeric_arg (argv[0], ARG (1), &value))
+  if (!numeric_arg (argv[0], ARG (1, argc, argv), &value))
     return;
 
   /* Minimize undefined C behavior on overflow.  This code assumes
@@ -1171,7 +1154,7 @@ m4_decr (struct obstack *obs, int argc, token_data **argv)
   if (bad_argc (argv[0], argc, 2, 2))
     return;
 
-  if (!numeric_arg (argv[0], ARG (1), &value))
+  if (!numeric_arg (argv[0], ARG (1, argc, argv), &value))
     return;
 
   /* Minimize undefined C behavior on overflow.  This code assumes
@@ -1198,7 +1181,7 @@ m4_divert (struct obstack *obs MAYBE_UNUSED, int argc, token_data **argv)
   if (bad_argc (argv[0], argc, 1, 2))
     return;
 
-  if (argc >= 2 && !numeric_arg (argv[0], ARG (1), &i))
+  if (argc >= 2 && !numeric_arg (argv[0], ARG (1, argc, argv), &i))
     return;
 
   make_diversion (i);
@@ -1235,25 +1218,25 @@ m4_undivert (struct obstack *obs MAYBE_UNUSED, int argc, token_data **argv)
   else
     for (i = 1; i < argc; i++)
       {
-        file = strtol (ARG (i), &endp, 10);
-        if (*endp == '\0' && !c_isspace (*ARG (i)))
+        file = strtol (ARG (i, argc, argv), &endp, 10);
+        if (*endp == '\0' && !c_isspace (*ARG (i, argc, argv)))
           insert_diversion (file);
         else if (no_gnu_extensions)
-          M4ERROR ((warning_status, 0,
-                    _("non-numeric argument to builtin `%s'"), ARG (0)));
+          M4ERROR(warning_status, 0,
+                    _("non-numeric argument to builtin `%s'"), ARG (0, argc, argv));
         else
           {
-            fp = m4_path_search (ARG (i), NULL);
+            fp = m4_path_search (ARG (i, argc, argv), NULL);
             if (fp != NULL)
               {
                 insert_file (fp);
                 if (fclose (fp) == EOF)
-                  M4ERROR ((warning_status, errno,
-                            _("error undiverting `%s'"), ARG (i)));
+                  M4ERROR(warning_status, errno,
+                            _("error undiverting `%s'"), ARG (i, argc, argv));
               }
             else
-              M4ERROR ((warning_status, errno,
-                        _("cannot undivert `%s'"), ARG (i)));
+              M4ERROR(warning_status, errno,
+                        _("cannot undivert `%s'"), ARG (i, argc, argv));
           }
       }
 }
@@ -1301,8 +1284,8 @@ m4_changequote (struct obstack *obs MAYBE_UNUSED, int argc,
     return;
 
   /* Explicit NULL distinguishes between empty and missing argument.  */
-  set_quotes ((argc >= 2) ? TOKEN_DATA_TEXT (argv[1]) : NULL,
-             (argc >= 3) ? TOKEN_DATA_TEXT (argv[2]) : NULL);
+  set_quotes ((argc >= 2) ? *TOKEN_DATA_TEXT (argv[1]) : NULL,
+             (argc >= 3) ? *TOKEN_DATA_TEXT (argv[2]) : NULL);
 }
 
 /*-----------------------------------------------------------------.
@@ -1317,8 +1300,8 @@ m4_changecom (struct obstack *obs MAYBE_UNUSED, int argc, token_data **argv)
     return;
 
   /* Explicit NULL distinguishes between empty and missing argument.  */
-  set_comment ((argc >= 2) ? TOKEN_DATA_TEXT (argv[1]) : NULL,
-               (argc >= 3) ? TOKEN_DATA_TEXT (argv[2]) : NULL);
+  set_comment ((argc >= 2) ? *TOKEN_DATA_TEXT (argv[1]) : NULL,
+               (argc >= 3) ? *TOKEN_DATA_TEXT (argv[2]) : NULL);
 }
 
 #ifdef ENABLE_CHANGEWORD
@@ -1334,7 +1317,7 @@ m4_changeword (struct obstack *obs MAYBE_UNUSED, int argc, token_data **argv)
   if (bad_argc (argv[0], argc, 2, 2))
     return;
 
-  set_word_regexp (TOKEN_DATA_TEXT (argv[1]));
+  set_word_regexp (*TOKEN_DATA_TEXT (argv[1]));
 }
 
 #endif /* ENABLE_CHANGEWORD */
@@ -1358,12 +1341,12 @@ include (int argc, token_data **argv, bool silent)
   if (bad_argc (argv[0], argc, 2, 2))
     return;
 
-  fp = m4_path_search (ARG (1), &name);
+  fp = m4_path_search (ARG (1, argc, argv), &name);
   if (fp == NULL)
     {
       if (!silent)
         {
-          M4ERROR ((warning_status, errno, _("cannot open `%s'"), ARG (1)));
+          M4ERROR(warning_status, errno, _("cannot open `%s'"), ARG (1, argc, argv));
           retcode = EXIT_FAILURE;
         }
       return;
@@ -1426,7 +1409,7 @@ mkstemp_helper (struct obstack *obs, const char *me, const char *pattern,
   fd = mkstemp (name);
   if (fd < 0)
     {
-      M4ERROR ((0, errno, _("%s: cannot create tempfile `%s'"), me, pattern));
+      M4ERROR(0, errno, _("%s: cannot create tempfile `%s'"), me, pattern);
       obstack_free (obs, obstack_finish (obs));
     }
   else
@@ -1456,12 +1439,12 @@ m4_maketemp (struct obstack *obs, int argc, token_data **argv)
            maketemp(XX) -> `Xn', where n is last digit of pid
            maketemp(XXXXXXXX) -> `X00nnnnn', where nnnnn is 16-bit pid
       */
-      const char *str = ARG (1);
+      const char *str = ARG (1, argc, argv);
       int len = strlen (str);
       int i;
       int len2;
 
-      M4ERROR ((warning_status, 0, _("recommend using mkstemp instead")));
+      M4ERROR(warning_status, 0, _("recommend using mkstemp instead"));
       for (i = len; i > 1; i--)
         if (str[i - 1] != 'X')
           break;
@@ -1478,7 +1461,7 @@ m4_maketemp (struct obstack *obs, int argc, token_data **argv)
         }
     }
   else
-    mkstemp_helper (obs, ARG (0), ARG (1), strlen (ARG (1)));
+    mkstemp_helper (obs, ARG (0, argc, argv), ARG (1, argc, argv), strlen (ARG (1, argc, argv)));
 }
 
 static void
@@ -1486,7 +1469,7 @@ m4_mkstemp (struct obstack *obs, int argc, token_data **argv)
 {
   if (bad_argc (argv[0], argc, 2, 2))
     return;
-  mkstemp_helper (obs, ARG (0), ARG (1), strlen (ARG (1)));
+  mkstemp_helper (obs, ARG (0, argc, argv), ARG (1, argc, argv), strlen (ARG (1, argc, argv)));
 }
 
 /*----------------------------------------.
@@ -1549,12 +1532,12 @@ m4_m4exit (struct obstack *obs MAYBE_UNUSED, int argc, token_data **argv)
 
   /* Warn on bad arguments, but still exit.  */
   bad_argc (argv[0], argc, 1, 2);
-  if (argc >= 2 && !numeric_arg (argv[0], ARG (1), &exit_code))
+  if (argc >= 2 && !numeric_arg (argv[0], ARG (1, argc, argv), &exit_code))
     exit_code = EXIT_FAILURE;
   if (exit_code < 0 || exit_code > 255)
     {
-      M4ERROR ((warning_status, 0,
-                _("exit status out of range: `%d'"), exit_code));
+      M4ERROR(warning_status, 0,
+                _("exit status out of range: `%d'"), exit_code);
       exit_code = EXIT_FAILURE;
     }
   /* Change debug stream back to stderr, to force flushing debug stream and
@@ -1581,7 +1564,7 @@ m4_m4wrap (struct obstack *obs, int argc, token_data **argv)
   if (bad_argc (argv[0], argc, 2, -1))
     return;
   if (no_gnu_extensions)
-    obstack_grow (obs, ARG (1), strlen (ARG (1)));
+    obstack_grow (obs, ARG (1, argc, argv), strlen (ARG (1, argc, argv)));
   else
     dump_args (obs, argc, argv, " ", false);
   obstack_1grow (obs, '\0');
@@ -1601,10 +1584,10 @@ m4_m4wrap (struct obstack *obs, int argc, token_data **argv)
 static void
 set_trace (symbol *sym, void *data)
 {
-  SYMBOL_TRACED (sym) = data != NULL;
+  SYMBOL_TRACED_set(sym, data != NULL);
   /* Remove placeholder from table if macro is undefined and untraced.  */
-  if (SYMBOL_TYPE (sym) == TOKEN_VOID && data == NULL)
-    lookup_symbol (SYMBOL_NAME (sym), SYMBOL_POPDEF);
+  if (*SYMBOL_TYPE (sym) == TOKEN_VOID && data == NULL)
+    lookup_symbol (*SYMBOL_NAME (sym), SYMBOL_POPDEF);
 }
 
 static void
@@ -1618,9 +1601,9 @@ m4_traceon (struct obstack *obs, int argc, token_data **argv)
   else
     for (i = 1; i < argc; i++)
       {
-        s = lookup_symbol (ARG (i), SYMBOL_LOOKUP);
+        s = lookup_symbol (ARG (i, argc, argv), SYMBOL_LOOKUP);
         if (!s)
-          s = lookup_symbol (ARG (i), SYMBOL_INSERT);
+          s = lookup_symbol (ARG (i, argc, argv), SYMBOL_INSERT);
         set_trace (s, obs);
       }
 }
@@ -1640,7 +1623,7 @@ m4_traceoff (struct obstack *obs MAYBE_UNUSED, int argc, token_data **argv)
   else
     for (i = 1; i < argc; i++)
       {
-        s = lookup_symbol (TOKEN_DATA_TEXT (argv[i]), SYMBOL_LOOKUP);
+        s = lookup_symbol (*TOKEN_DATA_TEXT (argv[i]), SYMBOL_LOOKUP);
         if (s != NULL)
           set_trace (s, NULL);
       }
@@ -1665,20 +1648,20 @@ m4_debugmode (struct obstack *obs MAYBE_UNUSED, int argc, token_data **argv)
     debug_level = 0;
   else
     {
-      if (ARG (1)[0] == '+' || ARG (1)[0] == '-')
+      if (ARG (1, argc, argv)[0] == '+' || ARG (1, argc, argv)[0] == '-')
         {
-          change_flag = ARG (1)[0];
-          new_debug_level = debug_decode (ARG (1) + 1);
+          change_flag = ARG (1, argc, argv)[0];
+          new_debug_level = debug_decode (ARG (1, argc, argv) + 1);
         }
       else
         {
           change_flag = 0;
-          new_debug_level = debug_decode (ARG (1));
+          new_debug_level = debug_decode (ARG (1, argc, argv));
         }
 
       if (new_debug_level < 0)
-        M4ERROR ((warning_status, 0,
-                  _("Debugmode: bad debug flags: `%s'"), ARG (1)));
+        M4ERROR(warning_status, 0,
+                  _("Debugmode: bad debug flags: `%s'"), ARG (1, argc, argv));
       else
         {
           switch (change_flag)
@@ -1696,8 +1679,8 @@ m4_debugmode (struct obstack *obs MAYBE_UNUSED, int argc, token_data **argv)
               break;
 
             default:
-              M4ERROR ((warning_status, 0,
-                        "INTERNAL ERROR: bad flag in m4_debugmode ()"));
+              M4ERROR(warning_status, 0,
+                        "INTERNAL ERROR: bad flag in m4_debugmode ()");
               abort ();
             }
         }
@@ -1717,9 +1700,9 @@ m4_debugfile (struct obstack *obs MAYBE_UNUSED, int argc, token_data **argv)
 
   if (argc == 1)
     debug_set_output (NULL);
-  else if (!debug_set_output (ARG (1)))
-    M4ERROR ((warning_status, errno,
-              _("cannot set debug file `%s'"), ARG (1)));
+  else if (!debug_set_output (ARG (1, argc, argv)))
+    M4ERROR(warning_status, errno,
+              _("cannot set debug file `%s'"), ARG (1, argc, argv));
 }
 
 /* This section contains text processing macros: "len", "index",
@@ -1735,7 +1718,7 @@ m4_len (struct obstack *obs, int argc, token_data **argv)
 {
   if (bad_argc (argv[0], argc, 2, 2))
     return;
-  shipout_int (obs, strlen (ARG (1)));
+  shipout_int (obs, strlen (ARG (1, argc, argv)));
 }
 
 /*-------------------------------------------------------------------.
@@ -1758,8 +1741,8 @@ m4_index (struct obstack *obs, int argc, token_data **argv)
       return;
     }
 
-  haystack = ARG (1);
-  result = strstr (haystack, ARG (2));
+  haystack = ARG (1, argc, argv);
+  result = strstr (haystack, ARG (2, argc, argv));
   retval = result ? result - haystack : -1;
 
   shipout_int (obs, retval);
@@ -1783,15 +1766,15 @@ m4_substr (struct obstack *obs, int argc, token_data **argv)
     {
       /* builtin(`substr') is blank, but substr(`abc') is abc.  */
       if (argc == 2)
-        obstack_grow (obs, ARG (1), strlen (ARG (1)));
+        obstack_grow (obs, ARG (1, argc, argv), strlen (ARG (1, argc, argv)));
       return;
     }
 
-  length = avail = strlen (ARG (1));
-  if (!numeric_arg (argv[0], ARG (2), &start))
+  length = avail = strlen (ARG (1, argc, argv));
+  if (!numeric_arg (argv[0], ARG (2, argc, argv), &start))
     return;
 
-  if (argc >= 4 && !numeric_arg (argv[0], ARG (3), &length))
+  if (argc >= 4 && !numeric_arg (argv[0], ARG (3, argc, argv), &length))
     return;
 
   if (start < 0 || length <= 0 || start >= avail)
@@ -1799,7 +1782,7 @@ m4_substr (struct obstack *obs, int argc, token_data **argv)
 
   if (start + length > avail)
     length = avail - start;
-  obstack_grow (obs, ARG (1) + start, length);
+  obstack_grow (obs, ARG (1, argc, argv) + start, length);
 }
 
 /*------------------------------------------------------------------.
@@ -1859,8 +1842,8 @@ expand_ranges (const char *s, struct obstack *obs)
 static void
 m4_translit (struct obstack *obs, int argc, token_data **argv)
 {
-  const char *data = ARG (1);
-  const char *from = ARG (2);
+  const char *data = ARG (1, argc, argv);
+  const char *from = ARG (2, argc, argv);
   const char *to;
   char map[UCHAR_MAX + 1];
   char found[UCHAR_MAX + 1];
@@ -1874,7 +1857,7 @@ m4_translit (struct obstack *obs, int argc, token_data **argv)
       return;
     }
 
-  to = ARG (3);
+  to = ARG (3, argc, argv);
   if (strchr (to, '-') != NULL)
     {
       to = expand_ranges (to, obs);
@@ -1930,7 +1913,7 @@ m4_translit (struct obstack *obs, int argc, token_data **argv)
         to++;
     }
 
-  for (data = ARG (1); (ch = *data) != '\0'; data++)
+  for (data = ARG (1, argc, argv); (ch = *data) != '\0'; data++)
     {
       if (! found[ch])
         obstack_1grow (obs, ch);
@@ -1985,8 +1968,8 @@ substitute (struct obstack *obs, const char *victim, const char *repl,
         case '0':
           if (!substitute_warned)
             {
-              M4ERROR ((warning_status, 0, _("\
-Warning: \\0 will disappear, use \\& instead in replacements")));
+              M4ERROR(warning_status, 0, _("\
+Warning: \\0 will disappear, use \\& instead in replacements"));
               substitute_warned = 1;
             }
           FALLTHROUGH;
@@ -2000,8 +1983,8 @@ Warning: \\0 will disappear, use \\& instead in replacements")));
         case '7': case '8': case '9':
           ind = ch -= '0';
           if (regs->num_regs - 1 <= ind)
-            M4ERROR ((warning_status, 0,
-                      _("Warning: sub-expression %d not present"), ch));
+            M4ERROR(warning_status, 0,
+                      _("Warning: sub-expression %d not present"), ch);
           else if (regs->end[ch] > 0)
             obstack_grow (obs, victim + regs->start[ch],
                           regs->end[ch] - regs->start[ch]);
@@ -2009,8 +1992,8 @@ Warning: \\0 will disappear, use \\& instead in replacements")));
           break;
 
         case '\0':
-          M4ERROR ((warning_status, 0,
-                    _("Warning: trailing \\ ignored in replacement")));
+          M4ERROR(warning_status, 0,
+                    _("Warning: trailing \\ ignored in replacement"));
           return;
 
         default:
@@ -2067,16 +2050,16 @@ m4_regexp (struct obstack *obs, int argc, token_data **argv)
       return;
     }
 
-  victim = TOKEN_DATA_TEXT (argv[1]);
-  regexp = TOKEN_DATA_TEXT (argv[2]);
+  victim = *TOKEN_DATA_TEXT (argv[1]);
+  regexp = *TOKEN_DATA_TEXT (argv[2]);
 
   init_pattern_buffer (&buf, &regs);
   msg = re_compile_pattern (regexp, strlen (regexp), &buf);
 
   if (msg != NULL)
     {
-      M4ERROR ((warning_status, 0,
-                _("bad regular expression: `%s': %s"), regexp, msg));
+      M4ERROR(warning_status, 0,
+                _("bad regular expression: `%s': %s"), regexp, msg);
       free_pattern_buffer (&buf, &regs);
       return;
     }
@@ -2087,13 +2070,13 @@ m4_regexp (struct obstack *obs, int argc, token_data **argv)
                         argc == 3 ? NULL : &regs);
 
   if (startpos == -2)
-    M4ERROR ((warning_status, 0,
-              _("error matching regular expression `%s'"), regexp));
+    M4ERROR(warning_status, 0,
+              _("error matching regular expression `%s'"), regexp);
   else if (argc == 3)
     shipout_int (obs, startpos);
   else if (startpos >= 0)
     {
-      repl = TOKEN_DATA_TEXT (argv[3]);
+      repl = *TOKEN_DATA_TEXT (argv[3]);
       substitute (obs, victim, repl, &regs);
     }
 
@@ -2124,24 +2107,24 @@ m4_patsubst (struct obstack *obs, int argc, token_data **argv)
     {
       /* builtin(`patsubst') is blank, but patsubst(`abc') is abc.  */
       if (argc == 2)
-        obstack_grow (obs, ARG (1), strlen (ARG (1)));
+        obstack_grow (obs, ARG (1, argc, argv), strlen (ARG (1, argc, argv)));
       return;
     }
 
-  regexp = TOKEN_DATA_TEXT (argv[2]);
+  regexp = *TOKEN_DATA_TEXT (argv[2]);
 
   init_pattern_buffer (&buf, &regs);
   msg = re_compile_pattern (regexp, strlen (regexp), &buf);
 
   if (msg != NULL)
     {
-      M4ERROR ((warning_status, 0,
-                _("bad regular expression `%s': %s"), regexp, msg));
+      M4ERROR(warning_status, 0,
+                _("bad regular expression `%s': %s"), regexp, msg);
       free (buf.buffer);
       return;
     }
 
-  victim = TOKEN_DATA_TEXT (argv[1]);
+  victim = *TOKEN_DATA_TEXT (argv[1]);
   length = strlen (victim);
 
   offset = 0;
@@ -2157,8 +2140,8 @@ m4_patsubst (struct obstack *obs, int argc, token_data **argv)
              copied verbatim.  */
 
           if (matchpos == -2)
-            M4ERROR ((warning_status, 0,
-                      _("error matching regular expression `%s'"), regexp));
+            M4ERROR(warning_status, 0,
+                      _("error matching regular expression `%s'"), regexp);
           else if (offset < length)
             obstack_grow (obs, victim + offset, length - offset);
           break;
@@ -2171,7 +2154,7 @@ m4_patsubst (struct obstack *obs, int argc, token_data **argv)
 
       /* Handle the part of the string that was covered by the match.  */
 
-      substitute (obs, victim, ARG (3), &regs);
+      substitute (obs, victim, ARG (3, argc, argv), &regs);
 
       /* Update the offset to the end of the match.  If the regexp
          matched a null string, advance offset one more, to avoid
@@ -2205,8 +2188,8 @@ void
 m4_placeholder (struct obstack *obs MAYBE_UNUSED, int argc,
                 token_data **argv)
 {
-  M4ERROR ((warning_status, 0, _("\
-builtin `%s' requested by frozen file is not supported"), ARG (0)));
+  M4ERROR(warning_status, 0, _("\
+builtin `%s' requested by frozen file is not supported"), ARG (0, argc, argv));
 }
 
 /*-------------------------------------------------------------------.
@@ -2221,7 +2204,7 @@ void
 expand_user_macro (struct obstack *obs, symbol *sym,
                    int argc, token_data **argv)
 {
-  const char *text = SYMBOL_TEXT (sym);
+  const char *text = *SYMBOL_TEXT (sym);
   int i;
   while (1)
     {
@@ -2247,8 +2230,8 @@ expand_user_macro (struct obstack *obs, symbol *sym,
                 i = i*10 + (*text - '0');
             }
           if (i < argc)
-            obstack_grow (obs, TOKEN_DATA_TEXT (argv[i]),
-                          strlen (TOKEN_DATA_TEXT (argv[i])));
+            obstack_grow (obs, *TOKEN_DATA_TEXT (argv[i]),
+                          strlen (*TOKEN_DATA_TEXT (argv[i])));
           break;
 
         case '#': /* number of arguments */
diff --git a/src/debug.c b/src/debug.c
index 47e589d..42ab9ea 100644
--- a/src/debug.c
+++ b/src/debug.c
@@ -133,7 +133,7 @@ debug_set_file (FILE *fp)
   if (debug != NULL && debug != stderr && debug != stdout
       && close_stream (debug) != 0)
     {
-      M4ERROR ((warning_status, errno, _("error writing to debug stream")));
+      M4ERROR(warning_status, errno, _("error writing to debug stream"));
       retcode = EXIT_FAILURE;
     }
   debug = fp;
@@ -153,8 +153,8 @@ debug_set_file (FILE *fp)
         {
           if (debug != stderr && close_stream (debug) != 0)
             {
-              M4ERROR ((warning_status, errno,
-                        _("error writing to debug stream")));
+              M4ERROR(warning_status, errno,
+                        _("error writing to debug stream"));
               retcode = EXIT_FAILURE;
             }
           debug = stdout;
@@ -382,18 +382,18 @@ trace_pre (const char *name, int id, int argc, token_data **argv)
           if (i != 1)
             trace_format (", ");
 
-          switch (TOKEN_DATA_TYPE (argv[i]))
+          switch (*TOKEN_DATA_TYPE (argv[i]))
             {
             case TOKEN_TEXT:
-              trace_format ("%l%S%r", TOKEN_DATA_TEXT (argv[i]));
+              trace_format ("%l%S%r", *TOKEN_DATA_TEXT (argv[i]));
               break;
 
             case TOKEN_FUNC:
-              bp = find_builtin_by_addr (TOKEN_DATA_FUNC (argv[i]));
+              bp = find_builtin_by_addr (*TOKEN_DATA_FUNC (argv[i]));
               if (bp == NULL)
                 {
-                  M4ERROR ((warning_status, 0, "\
-INTERNAL ERROR: builtin not found in builtin table! (trace_pre ())"));
+                  M4ERROR(warning_status, 0, "\
+INTERNAL ERROR: builtin not found in builtin table! (trace_pre ())");
                   abort ();
                 }
               trace_format ("<%s>", bp->name);
@@ -401,8 +401,8 @@ INTERNAL ERROR: builtin not found in builtin table! (trace_pre ())"));
 
             case TOKEN_VOID:
             default:
-              M4ERROR ((warning_status, 0,
-                        "INTERNAL ERROR: bad token data type (trace_pre ())"));
+              M4ERROR(warning_status, 0,
+                        "INTERNAL ERROR: bad token data type (trace_pre ())");
               abort ();
             }
 
diff --git a/src/eval.c b/src/eval.c
index 18e3a34..13e3835 100644
--- a/src/eval.c
+++ b/src/eval.c
@@ -314,50 +314,50 @@ evaluate (const char *expr, int32_t *val)
       break;
 
     case MISSING_RIGHT:
-      M4ERROR ((warning_status, 0,
+      M4ERROR(warning_status, 0,
                 _("bad expression in eval (missing right parenthesis): %s"),
-                expr));
+                expr);
       break;
 
     case SYNTAX_ERROR:
-      M4ERROR ((warning_status, 0,
-                _("bad expression in eval: %s"), expr));
+      M4ERROR(warning_status, 0,
+                _("bad expression in eval: %s"), expr);
       break;
 
     case UNKNOWN_INPUT:
-      M4ERROR ((warning_status, 0,
-                _("bad expression in eval (bad input): %s"), expr));
+      M4ERROR(warning_status, 0,
+                _("bad expression in eval (bad input): %s"), expr);
       break;
 
     case EXCESS_INPUT:
-      M4ERROR ((warning_status, 0,
-                _("bad expression in eval (excess input): %s"), expr));
+      M4ERROR(warning_status, 0,
+                _("bad expression in eval (excess input): %s"), expr);
       break;
 
     case INVALID_OPERATOR:
-      M4ERROR ((warning_status, 0,
-                _("invalid operator in eval: %s"), expr));
+      M4ERROR(warning_status, 0,
+                _("invalid operator in eval: %s"), expr);
       retcode = EXIT_FAILURE;
       break;
 
     case DIVIDE_ZERO:
-      M4ERROR ((warning_status, 0,
-                _("divide by zero in eval: %s"), expr));
+      M4ERROR(warning_status, 0,
+                _("divide by zero in eval: %s"), expr);
       break;
 
     case MODULO_ZERO:
-      M4ERROR ((warning_status, 0,
-                _("modulo by zero in eval: %s"), expr));
+      M4ERROR(warning_status, 0,
+                _("modulo by zero in eval: %s"), expr);
       break;
 
     case NEGATIVE_EXPONENT:
-      M4ERROR ((warning_status, 0,
-                _("negative exponent in eval: %s"), expr));
+      M4ERROR(warning_status, 0,
+                _("negative exponent in eval: %s"), expr);
       break;
 
     default:
-      M4ERROR ((warning_status, 0,
-                "INTERNAL ERROR: bad error code in evaluate ()"));
+      M4ERROR(warning_status, 0,
+                "INTERNAL ERROR: bad error code in evaluate ()");
       abort ();
     }
 
@@ -535,8 +535,8 @@ equality_term (eval_token et, int32_t *v1)
 
       if (op == ASSIGN)
       {
-        M4ERROR ((warning_status, 0, _("\
-Warning: recommend ==, not =, for equality operator")));
+        M4ERROR(warning_status, 0, _("\
+Warning: recommend ==, not =, for equality operator"));
         op = EQ;
       }
       *v1 = (op == EQ) == (*v1 == v2);
@@ -588,8 +588,8 @@ cmp_term (eval_token et, int32_t *v1)
           break;
 
         default:
-          M4ERROR ((warning_status, 0,
-                    "INTERNAL ERROR: bad comparison operator in cmp_term ()"));
+          M4ERROR(warning_status, 0,
+                    "INTERNAL ERROR: bad comparison operator in cmp_term ()");
           abort ();
         }
     }
@@ -642,8 +642,8 @@ shift_term (eval_token et, int32_t *v1)
           break;
 
         default:
-          M4ERROR ((warning_status, 0,
-                    "INTERNAL ERROR: bad shift operator in shift_term ()"));
+          M4ERROR(warning_status, 0,
+                    "INTERNAL ERROR: bad shift operator in shift_term ()");
           abort ();
         }
     }
@@ -739,8 +739,8 @@ mult_term (eval_token et, int32_t *v1)
           break;
 
         default:
-          M4ERROR ((warning_status, 0,
-                    "INTERNAL ERROR: bad operator in mult_term ()"));
+          M4ERROR(warning_status, 0,
+                    "INTERNAL ERROR: bad operator in mult_term ()");
           abort ();
         }
     }
diff --git a/src/format.c b/src/format.c
index 6f1758f..4758f17 100644
--- a/src/format.c
+++ b/src/format.c
@@ -37,17 +37,17 @@ arg_int (const char *str)
 
   if (!len)
     {
-      M4ERROR ((warning_status, 0, _("empty string treated as 0")));
+      M4ERROR(warning_status, 0, _("empty string treated as 0"));
       return 0;
     }
   errno = 0;
   value = strtol (str, &endp, 10);
   if (endp - str - len)
-    M4ERROR ((warning_status, 0, _("non-numeric argument %s"), str));
+    M4ERROR(warning_status, 0, _("non-numeric argument %s"), str);
   else if (c_isspace (*str))
-    M4ERROR ((warning_status, 0, _("leading whitespace ignored")));
+    M4ERROR(warning_status, 0, _("leading whitespace ignored"));
   else if (errno == ERANGE || (int) value != value)
-    M4ERROR ((warning_status, 0, _("numeric overflow detected")));
+    M4ERROR(warning_status, 0, _("numeric overflow detected"));
   return value;
 }
 
@@ -61,17 +61,17 @@ arg_long (const char *str)
 
   if (!len)
     {
-      M4ERROR ((warning_status, 0, _("empty string treated as 0")));
+      M4ERROR(warning_status, 0, _("empty string treated as 0"));
       return 0L;
     }
   errno = 0;
   value = strtol (str, &endp, 10);
   if (endp - str - len)
-    M4ERROR ((warning_status, 0, _("non-numeric argument %s"), str));
+    M4ERROR(warning_status, 0, _("non-numeric argument %s"), str);
   else if (c_isspace (*str))
-    M4ERROR ((warning_status, 0, _("leading whitespace ignored")));
+    M4ERROR(warning_status, 0, _("leading whitespace ignored"));
   else if (errno == ERANGE)
-    M4ERROR ((warning_status, 0, _("numeric overflow detected")));
+    M4ERROR(warning_status, 0, _("numeric overflow detected"));
   return value;
 }
 
@@ -85,35 +85,43 @@ arg_double (const char *str)
 
   if (!len)
     {
-      M4ERROR ((warning_status, 0, _("empty string treated as 0")));
+      M4ERROR(warning_status, 0, _("empty string treated as 0"));
       return 0.0;
     }
   errno = 0;
   value = strtod (str, &endp);
   if (endp - str - len)
-    M4ERROR ((warning_status, 0, _("non-numeric argument %s"), str));
+    M4ERROR(warning_status, 0, _("non-numeric argument %s"), str);
   else if (c_isspace (*str))
-    M4ERROR ((warning_status, 0, _("leading whitespace ignored")));
+    M4ERROR(warning_status, 0, _("leading whitespace ignored"));
   else if (errno == ERANGE)
-    M4ERROR ((warning_status, 0, _("numeric overflow detected")));
+    M4ERROR(warning_status, 0, _("numeric overflow detected"));
   return value;
 }
 
-#define ARG_INT(argc, argv) \
-        ((argc == 0) ? 0 : \
-         (--argc, argv++, arg_int (TOKEN_DATA_TEXT (argv[-1]))))
+static int ARG_INT(int *argc, token_data ***argv) {
+  return
+        (((*argc) == 0) ? 0 : 
+         (--(*argc), (*argv)++, arg_int (*TOKEN_DATA_TEXT ((*argv)[-1]))));
+}
 
-#define ARG_LONG(argc, argv) \
-        ((argc == 0) ? 0 : \
-         (--argc, argv++, arg_long (TOKEN_DATA_TEXT (argv[-1]))))
+static long ARG_LONG(int *argc, token_data ***argv) {
+  return
+    (((*argc) == 0) ? 0 :
+     (--(*argc), (*argv)++, arg_long(*TOKEN_DATA_TEXT((*argv)[-1]))));
+}
 
-#define ARG_STR(argc, argv) \
-        ((argc == 0) ? "" : \
-         (--argc, argv++, TOKEN_DATA_TEXT (argv[-1])))
+static char *ARG_STR(int *argc, token_data ***argv) {
+  return
+    (((*argc) == 0) ? "" :
+     (--(*argc), (*argv)++, *TOKEN_DATA_TEXT((*argv)[-1])));
+}
 
-#define ARG_DOUBLE(argc, argv) \
-        ((argc == 0) ? 0 : \
-         (--argc, argv++, arg_double (TOKEN_DATA_TEXT (argv[-1]))))
+static double ARG_DOUBLE(int *argc, token_data ***argv) {
+  return
+    (((*argc) == 0) ? 0 :
+     (--(*argc), (*argv)++, arg_double(*TOKEN_DATA_TEXT((*argv)[-1]))));
+}
 
 
 /*------------------------------------------------------------------.
@@ -159,7 +167,7 @@ expand_format (struct obstack *obs, int argc, token_data **argv)
   char *str;                    /* malloc'd buffer of formatted text */
   enum {CHAR, INT, LONG, DOUBLE, STR} datatype;
 
-  f = fmt = ARG_STR (argc, argv);
+  f = fmt = ARG_STR (&argc, &argv);
   memset (ok, 0, sizeof ok);
   while (1)
     {
@@ -246,7 +254,7 @@ expand_format (struct obstack *obs, int argc, token_data **argv)
       *p++ = '*';
       if (*fmt == '*')
         {
-          width = ARG_INT (argc, argv);
+          width = ARG_INT(&argc, &argv);
           fmt++;
         }
       else
@@ -266,7 +274,7 @@ expand_format (struct obstack *obs, int argc, token_data **argv)
           ok['c'] = 0;
           if (*(++fmt) == '*')
             {
-              prec = ARG_INT (argc, argv);
+              prec = ARG_INT(&argc, &argv);
               ++fmt;
             }
           else
@@ -304,8 +312,8 @@ expand_format (struct obstack *obs, int argc, token_data **argv)
       c = *fmt++;
       if (sizeof ok <= c || !ok[c])
         {
-          M4ERROR ((warning_status, 0,
-                    _("Warning: unrecognized specifier in `%s'"), f));
+          M4ERROR(warning_status, 0,
+                    _("Warning: unrecognized specifier in `%s'"), f);
           if (c == '\0')
             fmt--;
           continue;
@@ -358,23 +366,23 @@ expand_format (struct obstack *obs, int argc, token_data **argv)
       switch (datatype)
         {
         case CHAR:
-          str = xasprintf (fstart, width, ARG_INT(argc, argv));
+          str = xasprintf (fstart, width, ARG_INT(&argc, &argv));
           break;
 
         case INT:
-          str = xasprintf (fstart, width, prec, ARG_INT(argc, argv));
+          str = xasprintf (fstart, width, prec, ARG_INT(&argc, &argv));
           break;
 
         case LONG:
-          str = xasprintf (fstart, width, prec, ARG_LONG(argc, argv));
+          str = xasprintf (fstart, width, prec, ARG_LONG(&argc, &argv));
           break;
 
         case DOUBLE:
-          str = xasprintf (fstart, width, prec, ARG_DOUBLE(argc, argv));
+          str = xasprintf (fstart, width, prec, ARG_DOUBLE(&argc, &argv));
           break;
 
         case STR:
-          str = xasprintf (fstart, width, prec, ARG_STR(argc, argv));
+          str = xasprintf (fstart, width, prec, ARG_STR(&argc, &argv));
           break;
 
         default:
diff --git a/src/freeze.c b/src/freeze.c
index 94671c3..a08956c 100644
--- a/src/freeze.c
+++ b/src/freeze.c
@@ -36,8 +36,8 @@ reverse_symbol_list (symbol *sym)
   result = NULL;
   while (sym)
     {
-      next = SYMBOL_STACK (sym);
-      SYMBOL_STACK (sym) = result;
+      next = (*SYMBOL_STACK (sym));
+      (*SYMBOL_STACK (sym)) = result;
       result = sym;
       sym = next;
     }
@@ -56,31 +56,31 @@ freeze_symbol (symbol *sym, void *arg)
      executed with the oldest definitions first.  */
 
   s = reverse_symbol_list (s);
-  for (sym = s; sym; sym = SYMBOL_STACK (sym))
+  for (sym = s; sym; sym = (*SYMBOL_STACK (sym)))
     {
-      switch (SYMBOL_TYPE (sym))
+      switch (*SYMBOL_TYPE (sym))
         {
         case TOKEN_TEXT:
           xfprintf (file, "T%d,%d\n",
-                    (int) strlen (SYMBOL_NAME (sym)),
-                    (int) strlen (SYMBOL_TEXT (sym)));
-          fputs (SYMBOL_NAME (sym), file);
-          fputs (SYMBOL_TEXT (sym), file);
+                    (int) strlen (*SYMBOL_NAME (sym)),
+                    (int) strlen (*SYMBOL_TEXT (sym)));
+          fputs (*SYMBOL_NAME (sym), file);
+          fputs (*SYMBOL_TEXT (sym), file);
           fputc ('\n', file);
           break;
 
         case TOKEN_FUNC:
-          bp = find_builtin_by_addr (SYMBOL_FUNC (sym));
+          bp = find_builtin_by_addr (*SYMBOL_FUNC (sym));
           if (bp == NULL)
             {
-              M4ERROR ((warning_status, 0, "\
-INTERNAL ERROR: builtin not found in builtin table!"));
+              M4ERROR(warning_status, 0, "\
+INTERNAL ERROR: builtin not found in builtin table!");
               abort ();
             }
           xfprintf (file, "F%d,%d\n",
-                    (int) strlen (SYMBOL_NAME (sym)),
+                    (int) strlen (*SYMBOL_NAME (sym)),
                     (int) strlen (bp->name));
-          fputs (SYMBOL_NAME (sym), file);
+          fputs (*SYMBOL_NAME (sym), file);
           fputs (bp->name, file);
           fputc ('\n', file);
           break;
@@ -90,8 +90,8 @@ INTERNAL ERROR: builtin not found in builtin table!"));
           break;
 
         default:
-          M4ERROR ((warning_status, 0, "\
-INTERNAL ERROR: bad token data type in freeze_symbol ()"));
+          M4ERROR(warning_status, 0, "\
+INTERNAL ERROR: bad token data type in freeze_symbol ()");
           abort ();
           break;
         }
@@ -173,8 +173,72 @@ issue_expect_message (int expected)
 | Reload a frozen state from the given file NAME.  |
 `-------------------------------------------------*/
 
-/* We are seeking speed, here.  */
+static void GET_CHARACTER(bool *advance_line, int *character, FILE **file) {
+  if ((*advance_line))
+  {
+    current_line++;
+    (*advance_line) = false;
+  }
+  ((*character) = getc((*file)));
+  if ((*character) == '\n')
+    (*advance_line) = true;
+}
+
+static void GET_NUMBER(int *Number, bool AllowNeg, int *character, bool *advance_line, FILE **file) {
+  unsigned int n = 0;
+  while (c_isdigit((*character)) && n <= INT_MAX / 10U)
+  {
+    n = 10 * n + (*character) - '0';
+    GET_CHARACTER(advance_line, character, file);
+  }
+  if (((AllowNeg) ? INT_MIN : INT_MAX) + 0U < n
+      || c_isdigit((*character)))
+    m4_failure(0, _("integer overflow in frozen file"));
+  ((*Number)) = n;
+}
+
+static void GET_STRING(int i, int *number, int *allocated, char **string, FILE **file) {
+  void *tmp;
+  char *p;
+  if (number[(i)] + 1 > allocated[(i)])
+  {
+    free(string[(i)]);
+    allocated[(i)] = number[(i)] + 1;
+    string[(i)] = xcharalloc((size_t) allocated[(i)]);
+  }
+  if (number[(i)] > 0
+      && !fread(string[(i)], (size_t) number[(i)], 1, (*file)))
+    m4_failure(0, _("premature end of frozen file"));
+  string[(i)][number[(i)]] = '\0';
+  p = string[(i)];
+  while ((tmp = memchr(p, '\n', number[(i)] - (p - string[(i)]))))
+  {
+    current_line++;
+    p = (char *) tmp + 1;
+  }
+}
+
+static void VALIDATE(int Expected, int character) {
+  if (character != (Expected))
+    issue_expect_message(Expected);
+}
+
+ /* Skip comments (`#' at beginning of line) and blank lines, setting
+     character to the next directive or to EOF.  */
+
+static void GET_DIRECTIVE(bool *advance_line, int *character, FILE **file) {
+  do {
+    GET_CHARACTER(advance_line, character, file);
+    if ((*character) == '#')
+    {
+      while ((*character) != EOF && (*character) != '\n')
+        GET_CHARACTER(advance_line, character, file);
+      VALIDATE('\n', (*character));
+    }
+  } while (*character == '\n');
+}
 
+/* We are seeking speed, here.  */
 void
 reload_frozen_state (const char *name)
 {
@@ -187,84 +251,6 @@ reload_frozen_state (const char *name)
   const builtin *bp;
   bool advance_line = true;
 
-#define GET_CHARACTER                                           \
-  do                                                            \
-    {                                                           \
-      if (advance_line)                                         \
-        {                                                       \
-          current_line++;                                       \
-          advance_line = false;                                 \
-        }                                                       \
-      (character = getc (file));                                \
-      if (character == '\n')                                    \
-        advance_line = true;                                    \
-    }                                                           \
-  while (0)
-
-#define GET_NUMBER(Number, AllowNeg)                            \
-  do                                                            \
-    {                                                           \
-      unsigned int n = 0;                                       \
-      while (c_isdigit (character) && n <= INT_MAX / 10U)       \
-        {                                                       \
-          n = 10 * n + character - '0';                         \
-          GET_CHARACTER;                                        \
-        }                                                       \
-      if (((AllowNeg) ? INT_MIN : INT_MAX) + 0U < n             \
-          || c_isdigit (character))                             \
-        m4_failure (0, _("integer overflow in frozen file"));   \
-      (Number) = n;                                             \
-    }                                                           \
-  while (0)
-
-#define VALIDATE(Expected)                                      \
-  do                                                            \
-    {                                                           \
-      if (character != (Expected))                              \
-        issue_expect_message (Expected);                        \
-    }                                                           \
-  while (0)
-
-  /* Skip comments (`#' at beginning of line) and blank lines, setting
-     character to the next directive or to EOF.  */
-
-#define GET_DIRECTIVE                                           \
-  do                                                            \
-    {                                                           \
-      GET_CHARACTER;                                            \
-      if (character == '#')                                     \
-        {                                                       \
-          while (character != EOF && character != '\n')         \
-            GET_CHARACTER;                                      \
-          VALIDATE ('\n');                                      \
-        }                                                       \
-    }                                                           \
-  while (character == '\n')
-
-#define GET_STRING(i)                                                   \
-  do                                                                    \
-    {                                                                   \
-      void *tmp;                                                        \
-      char *p;                                                          \
-      if (number[(i)] + 1 > allocated[(i)])                             \
-        {                                                               \
-          free (string[(i)]);                                           \
-          allocated[(i)] = number[(i)] + 1;                             \
-          string[(i)] = xcharalloc ((size_t) allocated[(i)]);           \
-        }                                                               \
-      if (number[(i)] > 0                                               \
-          && !fread (string[(i)], (size_t) number[(i)], 1, file))       \
-        m4_failure (0, _("premature end of frozen file"));              \
-      string[(i)][number[(i)]] = '\0';                                  \
-      p = string[(i)];                                                  \
-      while ((tmp = memchr(p, '\n', number[(i)] - (p - string[(i)]))))  \
-        {                                                               \
-          current_line++;                                               \
-          p = (char *) tmp + 1;                                         \
-        }                                                               \
-    }                                                                   \
-  while (0)
-
   file = m4_path_search (name, NULL);
   if (file == NULL)
     m4_failure (errno, _("cannot open %s"), name);
@@ -276,19 +262,19 @@ reload_frozen_state (const char *name)
   string[1] = xcharalloc ((size_t) allocated[1]);
 
   /* Validate format version.  Only `1' is acceptable for now.  */
-  GET_DIRECTIVE;
-  VALIDATE ('V');
-  GET_CHARACTER;
-  GET_NUMBER (number[0], false);
+  GET_DIRECTIVE(&advance_line, &character, &file);
+  VALIDATE ('V', character);
+  GET_CHARACTER(&advance_line, &character, &file);
+  GET_NUMBER (&(number[0]), false, &character, &advance_line, &file);
   if (number[0] > 1)
-    M4ERROR ((EXIT_MISMATCH, 0,
+    M4ERROR(EXIT_MISMATCH, 0,
               _("frozen file version %d greater than max supported of 1"),
-              number[0]));
+              number[0]);
   else if (number[0] < 1)
     m4_failure (0, _("ill-formed frozen file, version directive expected"));
-  VALIDATE ('\n');
+  VALIDATE ('\n', character);
 
-  GET_DIRECTIVE;
+  GET_DIRECTIVE(&advance_line, &character, &file);
   while (character != EOF)
     {
       switch (character)
@@ -302,28 +288,28 @@ reload_frozen_state (const char *name)
         case 'T':
         case 'Q':
           operation = character;
-          GET_CHARACTER;
+          GET_CHARACTER(&advance_line, &character, &file);
 
           /* Get string lengths.  Accept a negative diversion number.  */
 
           if (operation == 'D' && character == '-')
             {
-              GET_CHARACTER;
-              GET_NUMBER (number[0], true);
+              GET_CHARACTER(&advance_line, &character, &file);
+              GET_NUMBER (&(number[0]), true, &character, &advance_line, &file);
               number[0] = -number[0];
             }
           else
-            GET_NUMBER (number[0], false);
-          VALIDATE (',');
-          GET_CHARACTER;
-          GET_NUMBER (number[1], false);
-          VALIDATE ('\n');
+            GET_NUMBER (&(number[0]), false, &character, &advance_line, &file);
+          VALIDATE (',', character);
+          GET_CHARACTER(&advance_line, &character, &file);
+          GET_NUMBER (&(number[1]), false, &character, &advance_line, &file);
+          VALIDATE ('\n', character);
 
           if (operation != 'D')
-            GET_STRING (0);
-          GET_STRING (1);
-          GET_CHARACTER;
-          VALIDATE ('\n');
+            GET_STRING (0, number, allocated, string, &file);
+          GET_STRING (1, number, allocated, string, &file);
+          GET_CHARACTER(&advance_line, &character, &file);
+          VALIDATE ('\n', character);
 
           /* Act according to operation letter.  */
 
@@ -376,7 +362,7 @@ reload_frozen_state (const char *name)
           break;
 
         }
-      GET_DIRECTIVE;
+      GET_DIRECTIVE(&advance_line, &character, &file);
     }
 
   free (string[0]);
@@ -386,9 +372,4 @@ reload_frozen_state (const char *name)
   current_file = NULL;
   current_line = 0;
 
-#undef GET_CHARACTER
-#undef GET_DIRECTIVE
-#undef GET_NUMBER
-#undef VALIDATE
-#undef GET_STRING
 }
diff --git a/src/input.c b/src/input.c
index 727ac7f..dc02e39 100644
--- a/src/input.c
+++ b/src/input.c
@@ -139,8 +139,8 @@ static bool start_of_input_line;
 /* Flag for next_char () to recognize change in input block.  */
 static bool input_change;
 
-#define CHAR_EOF        256     /* character return on EOF */
-#define CHAR_MACRO      257     /* character return for MACRO token */
+enum { CHAR_EOF = 256 };     /* character return on EOF */
+enum { CHAR_MACRO = 257 };     /* character return for MACRO token */
 
 /* Quote chars.  */
 STRING rquote;
@@ -159,7 +159,7 @@ static int default_word_regexp;
 static struct re_registers regs;
 
 #else /* ! ENABLE_CHANGEWORD */
-# define default_word_regexp 1
+enum { default_word_regexp = 1 };
 #endif /* ! ENABLE_CHANGEWORD */
 
 #ifdef DEBUG_INPUT
@@ -248,8 +248,8 @@ push_string_init (void)
 {
   if (next != NULL)
     {
-      M4ERROR ((warning_status, 0,
-                "INTERNAL ERROR: recursive push_string!"));
+      M4ERROR(warning_status, 0,
+                "INTERNAL ERROR: recursive push_string!");
       abort ();
     }
 
@@ -348,22 +348,22 @@ pop_input (void)
       if (debug_level & DEBUG_TRACE_INPUT)
         {
           if (tmp)
-            DEBUG_MESSAGE2 ("input reverted to %s, line %d",
-                            tmp->file, tmp->line);
+            DEBUG_MESSAGE2_str_int("input reverted to %s, line %d",
+                                   tmp->file, tmp->line);
           else
             DEBUG_MESSAGE ("input exhausted");
         }
 
       if (ferror (isp->u.u_f.fp))
         {
-          M4ERROR ((warning_status, 0, _("read error")));
+          M4ERROR(warning_status, 0, _("read error"));
           if (isp->u.u_f.close)
             fclose (isp->u.u_f.fp);
           retcode = EXIT_FAILURE;
         }
       else if (isp->u.u_f.close && fclose (isp->u.u_f.fp) == EOF)
         {
-          M4ERROR ((warning_status, errno, _("error reading file")));
+          M4ERROR(warning_status, errno, _("error reading file"));
           retcode = EXIT_FAILURE;
         }
       start_of_input_line = isp->u.u_f.advance;
@@ -371,8 +371,8 @@ pop_input (void)
       break;
 
     default:
-      M4ERROR ((warning_status, 0,
-                "INTERNAL ERROR: input stack botch in pop_input ()"));
+      M4ERROR(warning_status, 0,
+                "INTERNAL ERROR: input stack botch in pop_input ()");
       abort ();
     }
   obstack_free (current_input, isp);
@@ -431,13 +431,13 @@ init_macro_token (token_data *td)
 {
   if (isp->type != INPUT_MACRO)
     {
-      M4ERROR ((warning_status, 0,
-                "INTERNAL ERROR: bad call to init_macro_token ()"));
+      M4ERROR(warning_status, 0,
+                "INTERNAL ERROR: bad call to init_macro_token ()");
       abort ();
     }
 
-  TOKEN_DATA_TYPE (td) = TOKEN_FUNC;
-  TOKEN_DATA_FUNC (td) = isp->u.func;
+  *TOKEN_DATA_TYPE (td) = TOKEN_FUNC;
+  *TOKEN_DATA_FUNC (td) = isp->u.func;
 }
 
 
@@ -481,8 +481,8 @@ peek_input (void)
           return CHAR_MACRO;
 
         default:
-          M4ERROR ((warning_status, 0,
-                    "INTERNAL ERROR: input stack botch in peek_input ()"));
+          M4ERROR(warning_status, 0,
+                    "INTERNAL ERROR: input stack botch in peek_input ()");
           abort ();
         }
       block = block->prev;
@@ -497,13 +497,18 @@ peek_input (void)
 | ends, and the current line number is not incremented until the     |
 | next character is read.  99.9% of all calls will read from a       |
 | string, so factor that out into a macro for speed.                 |
+|                                                                    |
+| NOTE(ICSE 2024): Well it's not a macro anymore...                  |
 `-------------------------------------------------------------------*/
 
-#define next_char() \
-  (isp && isp->type == INPUT_STRING && isp->u.u_s.string[0]     \
-   && !input_change                                             \
-   ? to_uchar (*isp->u.u_s.string++)                            \
-   : next_char_1 ())
+static int next_char_1(void);
+
+static int next_char(void) {
+  return (isp && isp->type == INPUT_STRING && isp->u.u_s.string[0]
+   && !input_change
+   ? to_uchar (*isp->u.u_s.string++)
+   : next_char_1 ());
+}
 
 static int
 next_char_1 (void)
@@ -558,8 +563,8 @@ next_char_1 (void)
           return CHAR_MACRO;
 
         default:
-          M4ERROR ((warning_status, 0,
-                    "INTERNAL ERROR: input stack botch in next_char ()"));
+          M4ERROR(warning_status, 0,
+                    "INTERNAL ERROR: input stack botch in next_char ()");
           abort ();
         }
 
@@ -585,8 +590,8 @@ skip_line (void)
   if (ch == CHAR_EOF)
     /* current_file changed to "" if we see CHAR_EOF, use the
        previous value we stored earlier.  */
-    M4ERROR_AT_LINE ((warning_status, 0, file, line,
-                      _("Warning: end of file treated as newline")));
+    M4ERROR_AT_LINE(warning_status, 0, file, line,
+                    _("Warning: end of file treated as newline"));
   /* On the rare occasion that dnl crosses include file boundaries
      (either the input file did not end in a newline, or changeword
      was used), calling next_char can update current_file and
@@ -659,10 +664,11 @@ match_input (const char *s, bool consume)
 | effectively unchanged.                                              |
 `--------------------------------------------------------------------*/
 
-#define MATCH(ch, s, consume)                                           \
-  (to_uchar ((s)[0]) == (ch)                                            \
-   && (ch) != '\0'                                                      \
-   && ((s)[1] == '\0' || (match_input ((s) + (consume), consume))))
+static int MATCH(int ch, char *s, int consume) {
+  return (to_uchar((s)[0]) == (ch)
+          && (ch) != '\0'
+          && ((s)[1] == '\0' || (match_input((s) +(consume), consume))));
+}
 
 
 /*--------------------------------------------------------.
@@ -788,8 +794,8 @@ set_word_regexp (const char *regexp)
 
   if (msg != NULL)
     {
-      M4ERROR ((warning_status, 0,
-                _("bad regular expression `%s': %s"), regexp, msg));
+      M4ERROR(warning_status, 0,
+                _("bad regular expression `%s': %s"), regexp, msg);
       return;
     }
 
@@ -859,7 +865,7 @@ next_token (token_data *td, int *line)
       next_char ();
 #ifdef DEBUG_INPUT
       xfprintf (stderr, "next_token -> MACDEF (%s)\n",
-                find_builtin_by_addr (TOKEN_DATA_FUNC (td))->name);
+                find_builtin_by_addr (*TOKEN_DATA_FUNC (td))->name);
 #endif
       return TOKEN_MACDEF;
     }
@@ -1019,16 +1025,16 @@ next_token (token_data *td, int *line)
 
   obstack_1grow (&token_stack, '\0');
 
-  TOKEN_DATA_TYPE (td) = TOKEN_TEXT;
-  TOKEN_DATA_TEXT (td) = (char *) obstack_finish (&token_stack);
+  *TOKEN_DATA_TYPE (td) = TOKEN_TEXT;
+  *TOKEN_DATA_TEXT (td) = (char *) obstack_finish (&token_stack);
 #ifdef ENABLE_CHANGEWORD
   if (orig_text == NULL)
-    orig_text = TOKEN_DATA_TEXT (td);
+    orig_text = *TOKEN_DATA_TEXT (td);
   TOKEN_DATA_ORIG_TEXT (td) = orig_text;
 #endif
 #ifdef DEBUG_INPUT
   xfprintf (stderr, "next_token -> %s (%s)\n",
-            token_type_string (type), TOKEN_DATA_TEXT (td));
+            token_type_string (type), *TOKEN_DATA_TEXT (td));
 #endif
   return type;
 }
@@ -1140,14 +1146,14 @@ print_token (const char *s, token_type t, token_data *td)
       break;
 
     case TOKEN_MACDEF:
-      xfprintf (stderr, "macro: %p\n", TOKEN_DATA_FUNC (td));
+      xfprintf (stderr, "macro: %p\n", *TOKEN_DATA_FUNC (td));
       break;
 
     case TOKEN_EOF:
       xfprintf (stderr, "eof\n");
       break;
     }
-  xfprintf (stderr, "\t\"%s\"\n", TOKEN_DATA_TEXT (td));
+  xfprintf (stderr, "\t\"%s\"\n", *TOKEN_DATA_TEXT (td));
 }
 
 static void MAYBE_UNUSED
diff --git a/src/m4.c b/src/m4.c
index 2bd5775..883a6f1 100644
--- a/src/m4.c
+++ b/src/m4.c
@@ -38,7 +38,7 @@
 
 /* TRANSLATORS: This is a non-ASCII name: The first name is (with
    Unicode escapes) "Ren\u00e9" or (with HTML entities) "Ren&eacute;".  */
-#define AUTHORS proper_name_utf8 ("Rene' Seindal", "Ren\xC3\xA9 Seindal")
+const char *AUTHORS(void) { return proper_name_utf8("Rene' Seindal", "Ren\xC3\xA9 Seindal"); }
 
 static _Noreturn void usage (int);
 
@@ -94,6 +94,15 @@ typedef struct macro_definition macro_definition;
 /*-----------------------.
 | Wrapper around error.  |
 `-----------------------*/
+void M4ERROR(int status, int errnum, const char *format, ...) {
+  va_list args;
+  va_start(args, format);
+  verror_at_line(status, errnum, current_line ? current_file : NULL,
+                 current_line, format, args);
+  if (fatal_warnings && !retcode)
+    retcode = EXIT_FAILURE;
+  va_end(args);
+}
 
 void
 m4_error (int status, int errnum, const char *format, ...)
@@ -121,6 +130,16 @@ m4_failure (int errnum, const char *format, ...)
 | Wrapper around error_at_line.  |
 `-------------------------------*/
 
+void M4ERROR_AT_LINE(int status, int errnum, const char *file, int line,
+                const char *format, ...) {
+  va_list args;
+  va_start(args, format);
+  verror_at_line(status, errnum, line ? file : NULL, line, format, args);
+  if (fatal_warnings && !retcode)
+    retcode = EXIT_FAILURE;
+  va_end(args);
+}
+
 void
 m4_error_at_line (int status, int errnum, const char *file, int line,
                   const char *format, ...)
@@ -162,6 +181,10 @@ m4_failure_at_line (int errnum, const char *file, int line,
 static const char * volatile program_error_message;
 static const char * volatile signal_message[NSIG];
 
+static void WRITE(int f, const void *b, size_t l) {
+  ignore_value(write(f, b, l));
+}
+
 /* Print a nicer message about any programmer errors, then exit.  This
    must be aysnc-signal safe, since it is executed as a signal
    handler.  If SIGNO is zero, this represents a stack overflow; in
@@ -177,7 +200,6 @@ fault_handler (int signo)
          particular usage is safe.  And it seems an oversight that
          POSIX claims strlen is not async-safe.  Ignore write
          failures, since we will exit with non-zero status anyway.  */
-#define WRITE(f, b, l) ignore_value (write (f, b, l))
       WRITE (STDERR_FILENO, program_name, strlen (program_name));
       WRITE (STDERR_FILENO, ": ", 2);
       WRITE (STDERR_FILENO, program_error_message,
@@ -189,7 +211,6 @@ fault_handler (int signo)
                  strlen (signal_message[signo]));
         }
       WRITE (STDERR_FILENO, "\n", 1);
-#undef WRITE
       _exit (EXIT_INTERNAL_ERROR);
     }
 }
@@ -396,7 +417,7 @@ process_file (const char *name)
 #ifdef ENABLE_CHANGEWORD
 #define OPTSTRING "-B:D:EF:GH:I:L:N:PQR:S:T:U:W:d::egil:o:st:"
 #else
-#define OPTSTRING "-B:D:EF:GH:I:L:N:PQR:S:T:U:d::egil:o:st:"
+static const char *OPTSTRING = "-B:D:EF:GH:I:L:N:PQR:S:T:U:d::egil:o:st:";
 #endif
 
 int
@@ -609,7 +630,7 @@ main (int argc, char *const *argv)
         break;
 
       case VERSION_OPTION:
-        version_etc (stdout, PACKAGE, PACKAGE_NAME, VERSION, AUTHORS, NULL);
+        version_etc (stdout, PACKAGE, PACKAGE_NAME, VERSION, AUTHORS(), NULL);
         exit (EXIT_SUCCESS);
         break;
 
@@ -622,8 +643,8 @@ main (int argc, char *const *argv)
 
   /* Do the basic initializations.  */
   if (debugfile && !debug_set_output (debugfile))
-    M4ERROR ((warning_status, errno, _("cannot set debug file `%s'"),
-              debugfile));
+    M4ERROR(warning_status, errno, _("cannot set debug file `%s'"),
+              debugfile);
 
   input_init ();
   output_init ();
@@ -672,7 +693,7 @@ main (int argc, char *const *argv)
 
         case 't':
           sym = lookup_symbol (defines->arg, SYMBOL_INSERT);
-          SYMBOL_TRACED (sym) = true;
+          SYMBOL_TRACED_set(sym, true);
           break;
 
         case 's':
@@ -686,12 +707,12 @@ main (int argc, char *const *argv)
 
         case DEBUGFILE_OPTION:
           if (!debug_set_output (defines->arg))
-            M4ERROR ((warning_status, errno, _("cannot set debug file `%s'"),
-                      debugfile ? debugfile : _("stderr")));
+            M4ERROR(warning_status, errno, _("cannot set debug file `%s'"),
+                      debugfile ? debugfile : _("stderr"));
           break;
 
         default:
-          M4ERROR ((0, 0, "INTERNAL ERROR: bad code in deferred arguments"));
+          M4ERROR(0, 0, "INTERNAL ERROR: bad code in deferred arguments");
           abort ();
         }
 
diff --git a/src/m4.h b/src/m4.h
index b9ee884..43509b4 100644
--- a/src/m4.h
+++ b/src/m4.h
@@ -57,29 +57,35 @@
 #include "xvasprintf.h"
 
 /* Canonicalize UNIX recognition macros.  */
-#if defined unix || defined __unix || defined __unix__ \
+#if (defined unix || defined __unix || defined __unix__ \
   || defined _POSIX_VERSION || defined _POSIX2_VERSION \
   || defined __NetBSD__ || defined __OpenBSD__ \
-  || defined __APPLE__ || defined __APPLE_CC__
-# define UNIX 1
+  || defined __APPLE__ || defined __APPLE_CC__) \
+  && ! defined __EMX__
+enum { UNIX = 1 };
+#else
+enum { UNIX = 0 };
 #endif
 
 /* Canonicalize Windows recognition macros.  */
 #if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__
-# define W32_NATIVE 1
+enum { W32_NATIVE = 1 };
+#else
+enum { W32_NATIVE = 0 };
 #endif
 
 /* Canonicalize OS/2 recognition macro.  */
 #ifdef __EMX__
-# define OS2 1
-# undef UNIX
+enum { OS2 = 1 };
+#else
+enum { OS2 = 0 };
 #endif
 
 /* Used if any programmer error is detected (not possible, right?)  */
-#define EXIT_INTERNAL_ERROR 2
+enum { EXIT_INTERNAL_ERROR = 2 };
 
 /* Used for version mismatch, when -R detects a frozen file it can't parse.  */
-#define EXIT_MISMATCH 63
+enum { EXIT_MISMATCH = 63 };
 
 /* NLS.  */
 
@@ -91,7 +97,9 @@
 # define bindtextdomain(Domainname, Dirname) /* empty */
 #endif
 
-#define _(msgid) gettext (msgid)
+// #define _(msgid) gettext (msgid)
+static char *_(const char *msgid) __attribute_format_arg__(1);
+static char *_(const char *msgid) { return gettext(msgid); }
 
 /* Various declarations.  */
 
@@ -103,8 +111,8 @@ struct string
 typedef struct string STRING;
 
 /* Memory allocation.  */
-#define obstack_chunk_alloc     xmalloc
-#define obstack_chunk_free      free
+static void *obstack_chunk_alloc(size_t n) { return xmalloc(n); }
+static void obstack_chunk_free(void *ptr) { free(ptr); }
 
 /* Those must come first.  */
 typedef struct token_data token_data;
@@ -148,8 +156,9 @@ extern _Noreturn void m4_failure_at_line (int, const char *, int,
                                           const char *, ...)
   ATTRIBUTE_FORMAT ((__printf__, 4, 5));
 
-#define M4ERROR(Arglist) (m4_error Arglist)
-#define M4ERROR_AT_LINE(Arglist) (m4_error_at_line Arglist)
+void M4ERROR(int status, int errnum, const char *format, ...);
+void M4ERROR_AT_LINE(int status, int errnum, const char *file, int line,
+                     const char *format, ...);
 
 
 /* File: debug.c  --- debugging and tracing function.  */
@@ -159,82 +168,45 @@ extern FILE *debug;
 /* The value of debug_level is a bitmask of the following.  */
 
 /* a: show arglist in trace output */
-#define DEBUG_TRACE_ARGS 1
+enum { DEBUG_TRACE_ARGS = 1 };
 /* e: show expansion in trace output */
-#define DEBUG_TRACE_EXPANSION 2
+enum { DEBUG_TRACE_EXPANSION = 2 };
 /* q: quote args and expansion in trace output */
-#define DEBUG_TRACE_QUOTE 4
+enum { DEBUG_TRACE_QUOTE = 4 };
 /* t: trace all macros -- overrides trace{on,off} */
-#define DEBUG_TRACE_ALL 8
+enum { DEBUG_TRACE_ALL = 8 };
 /* l: add line numbers to trace output */
-#define DEBUG_TRACE_LINE 16
+enum { DEBUG_TRACE_LINE = 16 };
 /* f: add file name to trace output */
-#define DEBUG_TRACE_FILE 32
+enum { DEBUG_TRACE_FILE = 32 };
 /* p: trace path search of include files */
-#define DEBUG_TRACE_PATH 64
+enum { DEBUG_TRACE_PATH = 64 };
 /* c: show macro call before args collection */
-#define DEBUG_TRACE_CALL 128
+enum { DEBUG_TRACE_CALL = 128 };
 /* i: trace changes of input files */
-#define DEBUG_TRACE_INPUT 256
+enum {DEBUG_TRACE_INPUT = 256 };
 /* x: add call id to trace output */
-#define DEBUG_TRACE_CALLID 512
+enum { DEBUG_TRACE_CALLID = 512 };
 
 /* V: very verbose --  print everything */
-#define DEBUG_TRACE_VERBOSE 1023
+enum { DEBUG_TRACE_VERBOSE = 1023 };
 /* default flags -- equiv: aeq */
-#define DEBUG_TRACE_DEFAULT 7
-
-#define DEBUG_PRINT1(Fmt, Arg1) \
-  do                                                            \
-    {                                                           \
-      if (debug != NULL)                                        \
-        xfprintf (debug, Fmt, Arg1);                            \
-    }                                                           \
-  while (0)
-
-#define DEBUG_PRINT3(Fmt, Arg1, Arg2, Arg3) \
-  do                                                            \
-    {                                                           \
-      if (debug != NULL)                                        \
-        xfprintf (debug, Fmt, Arg1, Arg2, Arg3);                \
-    }                                                           \
-  while (0)
-
-#define DEBUG_MESSAGE(Fmt) \
-  do                                                            \
-    {                                                           \
-      if (debug != NULL)                                        \
-        {                                                       \
-          debug_message_prefix ();                              \
-          xfprintf (debug, Fmt);                                \
-          putc ('\n', debug);                                   \
-        }                                                       \
-    }                                                           \
-  while (0)
-
-#define DEBUG_MESSAGE1(Fmt, Arg1) \
-  do                                                            \
-    {                                                           \
-      if (debug != NULL)                                        \
-        {                                                       \
-          debug_message_prefix ();                              \
-          xfprintf (debug, Fmt, Arg1);                          \
-          putc ('\n', debug);                                   \
-        }                                                       \
-    }                                                           \
-  while (0)
-
-#define DEBUG_MESSAGE2(Fmt, Arg1, Arg2) \
-  do                                                            \
-    {                                                           \
-      if (debug != NULL)                                        \
-        {                                                       \
-          debug_message_prefix ();                              \
-          xfprintf (debug, Fmt, Arg1, Arg2);                    \
-          putc ('\n', debug);                                   \
-        }                                                       \
-    }                                                           \
-  while (0)
+enum { DEBUG_TRACE_DEFAULT = 7 };
+
+static void DEBUG_PRINT1(const char *__restrict__ Fmt, char *Arg1) {
+  if (debug != NULL)
+    xfprintf(debug, Fmt, Arg1);
+}
+
+static void DEBUG_PRINT1_const(const char *__restrict__ Fmt, const char *Arg1) {
+  if (debug != NULL)
+    xfprintf(debug, Fmt, Arg1);
+}
+
+static void DEBUG_PRINT3(const char *__restrict__ Fmt, char *Arg1, char *Arg2, char *Arg3) {
+  if (debug != NULL)
+    xfprintf(debug, Fmt, Arg1, Arg2, Arg3);
+}
 
 extern void debug_init (void);
 extern int debug_decode (const char *);
@@ -242,6 +214,42 @@ extern void debug_flush_files (void);
 extern bool debug_set_output (const char *);
 extern void debug_message_prefix (void);
 
+static void DEBUG_MESSAGE(const char *__restrict__ Fmt) {
+  if (debug != NULL)
+  {
+    debug_message_prefix();
+    xfprintf(debug, "%s", Fmt);
+    putc('\n', debug);
+  }
+}
+
+static void DEBUG_MESSAGE1(const char *__restrict__ Fmt, const char *Arg1) {
+  if (debug != NULL)
+  {
+    debug_message_prefix();
+    xfprintf(debug, Fmt, Arg1);
+    putc('\n', debug);
+  }
+}
+
+static void DEBUG_MESSAGE2_str_int(const char *__restrict__ Fmt, const char *Arg1, int Arg2) {
+  if (debug != NULL)
+  {
+    debug_message_prefix();
+    xfprintf(debug, Fmt, Arg1, Arg2);
+    putc('\n', debug);
+  }
+}
+
+static void DEBUG_MESSAGE2_str_str(const char *__restrict__ Fmt, const char *Arg1, char *Arg2) {
+  if (debug != NULL)
+  {
+    debug_message_prefix();
+    xfprintf(debug, Fmt, Arg1, Arg2);
+    putc('\n', debug);
+  }
+}
+
 extern void trace_prepre (const char *, int);
 extern void trace_pre (const char *, int, int, token_data **);
 extern void trace_post (const char *, int, int, const char *);
@@ -287,16 +295,25 @@ struct token_data
   u;
 };
 
-#define TOKEN_DATA_TYPE(Td)             ((Td)->type)
-#define TOKEN_DATA_TEXT(Td)             ((Td)->u.u_t.text)
+static char **TOKEN_DATA_TEXT(token_data *Td) {
+  return &((Td)->u.u_t.text);
+}
+
 #ifdef ENABLE_CHANGEWORD
 # define TOKEN_DATA_ORIG_TEXT(Td)       ((Td)->u.u_t.original_text)
 #endif
-#define TOKEN_DATA_FUNC(Td)             ((Td)->u.func)
+
+static builtin_func **TOKEN_DATA_FUNC(token_data *Td) {
+  return &((Td)->u.func);
+}
 
 typedef enum token_type token_type;
 typedef enum token_data_type token_data_type;
 
+static token_data_type *TOKEN_DATA_TYPE(token_data *Td) {
+  return &((Td)->type);
+}
+
 extern void input_init (void);
 extern token_type peek_token (void);
 extern token_type next_token (token_data *, int *);
@@ -320,10 +337,10 @@ extern STRING ecomm;
 extern STRING lquote;
 extern STRING rquote;
 
-#define DEF_LQUOTE "`"
-#define DEF_RQUOTE "\'"
-#define DEF_BCOMM "#"
-#define DEF_ECOMM "\n"
+static const char *DEF_LQUOTE = "`";
+static const char *DEF_RQUOTE = "\'";
+static const char *DEF_BCOMM = "#";
+static const char *DEF_ECOMM = "\n";
 
 extern void set_quotes (const char *, const char *);
 extern void set_comment (const char *, const char *);
@@ -372,22 +389,68 @@ struct symbol
   token_data data;
 };
 
-#define SYMBOL_STACK(S)         ((S)->stack)
-#define SYMBOL_TRACED(S)        ((S)->traced)
-#define SYMBOL_MACRO_ARGS(S)    ((S)->macro_args)
-#define SYMBOL_BLIND_NO_ARGS(S) ((S)->blind_no_args)
-#define SYMBOL_DELETED(S)       ((S)->deleted)
-#define SYMBOL_PENDING_EXPANSIONS(S) ((S)->pending_expansions)
-#define SYMBOL_NAME(S)          ((S)->name)
-#define SYMBOL_TYPE(S)          (TOKEN_DATA_TYPE (&(S)->data))
-#define SYMBOL_TEXT(S)          (TOKEN_DATA_TEXT (&(S)->data))
-#define SYMBOL_FUNC(S)          (TOKEN_DATA_FUNC (&(S)->data))
-
 typedef enum symbol_lookup symbol_lookup;
 typedef struct symbol symbol;
 typedef void hack_symbol (symbol *, void *);
 
-#define HASHMAX 65537             /* default, overridden by -Hsize */
+static symbol **SYMBOL_STACK(symbol *S) {
+  return &(S->stack);
+}
+
+static bool_bitfield SYMBOL_TRACED_get(symbol *S) {
+  return S->traced;
+}
+
+static void SYMBOL_TRACED_set(symbol *S, int traced) {
+  S->traced = traced;
+}
+
+static bool_bitfield SYMBOL_MACRO_ARGS_get(symbol *S) {
+  return S->macro_args;
+}
+
+static void SYMBOL_MACRO_ARGS_set(symbol *S, int macro_args) {
+  S->macro_args = macro_args;
+}
+
+static bool_bitfield SYMBOL_BLIND_NO_ARGS_get(symbol *S) {
+  return S->blind_no_args;
+}
+
+static void SYMBOL_BLIND_NO_ARGS_set(symbol *S, int blind_no_args) {
+  S->blind_no_args = blind_no_args;
+}
+
+static bool_bitfield SYMBOL_DELETED_get(symbol *S) {
+  return S->deleted;
+}
+
+static void SYMBOL_DELETED_set(symbol *S, int deleted) {
+  S->deleted = deleted;
+}
+
+static int *SYMBOL_PENDING_EXPANSIONS(symbol *S) {
+  return &((S)->pending_expansions);
+}
+
+static token_data_type *SYMBOL_TYPE(symbol *S) {
+  return &*TOKEN_DATA_TYPE(&(S)->data);
+}
+
+static builtin_func **SYMBOL_FUNC(symbol *S) {
+  return &*TOKEN_DATA_FUNC (&(S)->data);
+}
+
+static char **SYMBOL_NAME(symbol *S) {
+  return &((S)->name);
+}
+
+static char **SYMBOL_TEXT(symbol *S) {
+  return &(*TOKEN_DATA_TEXT(&(S)->data));
+}
+
+
+enum { HASHMAX = 65537 };             /* default, overridden by -Hsize */
 
 extern void free_symbol (symbol *sym);
 extern void symtab_init (void);
@@ -427,7 +490,7 @@ struct re_registers;
 /* The default sequence detects multi-digit parameters (obsolete after
    1.4.x), and any use of extended arguments with the default ${}
    syntax (new in 2.0).  */
-#define DEFAULT_MACRO_SEQUENCE "\\$\\({[^}]*}\\|[0-9][0-9]+\\)"
+static const char *DEFAULT_MACRO_SEQUENCE = "\\$\\({[^}]*}\\|[0-9][0-9]+\\)";
 
 extern void builtin_init (void);
 extern void define_builtin (const char *, const builtin *, symbol_lookup);
diff --git a/src/macro.c b/src/macro.c
index 7359e43..f3116ec 100644
--- a/src/macro.c
+++ b/src/macro.c
@@ -95,23 +95,23 @@ expand_token (struct obstack *obs, token_type t, token_data *td, int line)
     case TOKEN_CLOSE:
     case TOKEN_SIMPLE:
     case TOKEN_STRING:
-      shipout_text (obs, TOKEN_DATA_TEXT (td), strlen (TOKEN_DATA_TEXT (td)),
+      shipout_text (obs, *TOKEN_DATA_TEXT (td), strlen (*TOKEN_DATA_TEXT (td)),
                     line);
       break;
 
     case TOKEN_WORD:
-      sym = lookup_symbol (TOKEN_DATA_TEXT (td), SYMBOL_LOOKUP);
-      if (sym == NULL || SYMBOL_TYPE (sym) == TOKEN_VOID
-          || (SYMBOL_TYPE (sym) == TOKEN_FUNC
-              && SYMBOL_BLIND_NO_ARGS (sym)
+      sym = lookup_symbol (*TOKEN_DATA_TEXT (td), SYMBOL_LOOKUP);
+      if (sym == NULL || *SYMBOL_TYPE (sym) == TOKEN_VOID
+          || (*SYMBOL_TYPE (sym) == TOKEN_FUNC
+              && SYMBOL_BLIND_NO_ARGS_get(sym)
               && peek_token () != TOKEN_OPEN))
         {
 #ifdef ENABLE_CHANGEWORD
           shipout_text (obs, TOKEN_DATA_ORIG_TEXT (td),
                         strlen (TOKEN_DATA_ORIG_TEXT (td)), line);
 #else
-          shipout_text (obs, TOKEN_DATA_TEXT (td),
-                        strlen (TOKEN_DATA_TEXT (td)), line);
+          shipout_text (obs, *TOKEN_DATA_TEXT (td),
+                        strlen (*TOKEN_DATA_TEXT (td)), line);
 #endif
         }
       else
@@ -119,8 +119,8 @@ expand_token (struct obstack *obs, token_type t, token_data *td, int line)
       break;
 
     default:
-      M4ERROR ((warning_status, 0,
-                "INTERNAL ERROR: bad token type in expand_token ()"));
+      M4ERROR(warning_status, 0,
+                "INTERNAL ERROR: bad token type in expand_token ()");
       abort ();
     }
 }
@@ -146,14 +146,14 @@ expand_argument (struct obstack *obs, token_data *argp)
   const char *file = current_file;
   int line = current_line;
 
-  TOKEN_DATA_TYPE (argp) = TOKEN_VOID;
+  *TOKEN_DATA_TYPE (argp) = TOKEN_VOID;
 
   /* Skip leading white space.  */
   do
     {
       t = next_token (&td, NULL);
     }
-  while (t == TOKEN_SIMPLE && c_isspace (*TOKEN_DATA_TEXT (&td)));
+  while (t == TOKEN_SIMPLE && c_isspace (**TOKEN_DATA_TEXT (&td)));
 
   paren_level = 0;
 
@@ -170,17 +170,17 @@ expand_argument (struct obstack *obs, token_data *argp)
               obstack_1grow (obs, '\0');
               text = (char *) obstack_finish (obs);
 
-              if (TOKEN_DATA_TYPE (argp) == TOKEN_VOID)
+              if (*TOKEN_DATA_TYPE (argp) == TOKEN_VOID)
                 {
-                  TOKEN_DATA_TYPE (argp) = TOKEN_TEXT;
-                  TOKEN_DATA_TEXT (argp) = text;
+                  *TOKEN_DATA_TYPE (argp) = TOKEN_TEXT;
+                  *TOKEN_DATA_TEXT (argp) = text;
                 }
               return t == TOKEN_COMMA;
             }
           FALLTHROUGH;
         case TOKEN_OPEN:
         case TOKEN_SIMPLE:
-          text = TOKEN_DATA_TEXT (&td);
+          text = *TOKEN_DATA_TEXT (&td);
 
           if (*text == '(')
             paren_level++;
@@ -203,14 +203,14 @@ expand_argument (struct obstack *obs, token_data *argp)
         case TOKEN_MACDEF:
           if (obstack_object_size (obs) == 0)
             {
-              TOKEN_DATA_TYPE (argp) = TOKEN_FUNC;
-              TOKEN_DATA_FUNC (argp) = TOKEN_DATA_FUNC (&td);
+              *TOKEN_DATA_TYPE (argp) = TOKEN_FUNC;
+              *TOKEN_DATA_FUNC (argp) = *TOKEN_DATA_FUNC (&td);
             }
           break;
 
         default:
-          M4ERROR ((warning_status, 0,
-                    "INTERNAL ERROR: bad token type in expand_argument ()"));
+          M4ERROR(warning_status, 0,
+                    "INTERNAL ERROR: bad token type in expand_argument ()");
           abort ();
         }
 
@@ -231,10 +231,10 @@ collect_arguments (symbol *sym, struct obstack *argptr,
   token_data td;
   token_data *tdp;
   bool more_args;
-  bool groks_macro_args = SYMBOL_MACRO_ARGS (sym);
+  bool groks_macro_args = SYMBOL_MACRO_ARGS_get(sym);
 
-  TOKEN_DATA_TYPE (&td) = TOKEN_TEXT;
-  TOKEN_DATA_TEXT (&td) = SYMBOL_NAME (sym);
+  *TOKEN_DATA_TYPE (&td) = TOKEN_TEXT;
+  *TOKEN_DATA_TEXT (&td) = *SYMBOL_NAME (sym);
   tdp = (token_data *) obstack_copy (arguments, &td, sizeof td);
   obstack_ptr_grow (argptr, tdp);
 
@@ -245,10 +245,10 @@ collect_arguments (symbol *sym, struct obstack *argptr,
         {
           more_args = expand_argument (arguments, &td);
 
-          if (!groks_macro_args && TOKEN_DATA_TYPE (&td) == TOKEN_FUNC)
+          if (!groks_macro_args && *TOKEN_DATA_TYPE (&td) == TOKEN_FUNC)
             {
-              TOKEN_DATA_TYPE (&td) = TOKEN_TEXT;
-              TOKEN_DATA_TEXT (&td) = (char *) "";
+              *TOKEN_DATA_TYPE (&td) = TOKEN_TEXT;
+              *TOKEN_DATA_TEXT (&td) = (char *) "";
             }
           tdp = (token_data *) obstack_copy (arguments, &td, sizeof td);
           obstack_ptr_grow (argptr, tdp);
@@ -272,10 +272,10 @@ void
 call_macro (symbol *sym, int argc, token_data **argv,
                  struct obstack *expansion)
 {
-  switch (SYMBOL_TYPE (sym))
+  switch (*SYMBOL_TYPE (sym))
     {
     case TOKEN_FUNC:
-      (*SYMBOL_FUNC (sym)) (expansion, argc, argv);
+      (**SYMBOL_FUNC (sym)) (expansion, argc, argv);
       break;
 
     case TOKEN_TEXT:
@@ -284,8 +284,8 @@ call_macro (symbol *sym, int argc, token_data **argv,
 
     case TOKEN_VOID:
     default:
-      M4ERROR ((warning_status, 0,
-                "INTERNAL ERROR: bad symbol type in call_macro ()"));
+      M4ERROR(warning_status, 0,
+                "INTERNAL ERROR: bad symbol type in call_macro ()");
       abort ();
     }
 }
@@ -326,7 +326,7 @@ expand_macro (symbol *sym)
   const char *loc_close_file;
   int loc_close_line;
 
-  SYMBOL_PENDING_EXPANSIONS (sym)++;
+  (*SYMBOL_PENDING_EXPANSIONS (sym))++;
   expansion_level++;
   if (nesting_limit > 0 && expansion_level > nesting_limit)
     m4_failure (0, _("recursion limit of %d exceeded, use -L<N> to change it"),
@@ -335,7 +335,7 @@ expand_macro (symbol *sym)
   macro_call_id++;
   my_call_id = macro_call_id;
 
-  traced = (debug_level & DEBUG_TRACE_ALL) || SYMBOL_TRACED (sym);
+  traced = (debug_level & DEBUG_TRACE_ALL) || SYMBOL_TRACED_get(sym);
 
   argv_base = obstack_object_size (&argv_stack);
   if (obstack_object_size (&argc_stack) > 0)
@@ -348,7 +348,7 @@ expand_macro (symbol *sym)
     }
 
   if (traced && (debug_level & DEBUG_TRACE_CALL))
-    trace_prepre (SYMBOL_NAME (sym), my_call_id);
+    trace_prepre (*SYMBOL_NAME (sym), my_call_id);
 
   collect_arguments (sym, &argv_stack,
                      use_argc_stack ? &argc_stack : &arguments);
@@ -363,22 +363,22 @@ expand_macro (symbol *sym)
   current_line = loc_open_line;
 
   if (traced)
-    trace_pre (SYMBOL_NAME (sym), my_call_id, argc, argv);
+    trace_pre (*SYMBOL_NAME (sym), my_call_id, argc, argv);
 
   expansion = push_string_init ();
   call_macro (sym, argc, argv, expansion);
   expanded = push_string_finish ();
 
   if (traced)
-    trace_post (SYMBOL_NAME (sym), my_call_id, argc, expanded);
+    trace_post (*SYMBOL_NAME (sym), my_call_id, argc, expanded);
 
   current_file = loc_close_file;
   current_line = loc_close_line;
 
   --expansion_level;
-  --SYMBOL_PENDING_EXPANSIONS (sym);
+  --(*SYMBOL_PENDING_EXPANSIONS (sym));
 
-  if (SYMBOL_DELETED (sym))
+  if (SYMBOL_DELETED_get(sym))
     free_symbol (sym);
 
   if (use_argc_stack)
diff --git a/src/output.c b/src/output.c
index 6f148ce..d340055 100644
--- a/src/output.c
+++ b/src/output.c
@@ -29,14 +29,14 @@
 
 /* Size of initial in-memory buffer size for diversions.  Small diversions
    would usually fit in.  */
-#define INITIAL_BUFFER_SIZE 512
+enum { INITIAL_BUFFER_SIZE = 512 };
 
 /* Maximum value for the total of all in-memory buffer sizes for
    diversions.  */
-#define MAXIMUM_TOTAL_SIZE (512 * 1024)
+enum { MAXIMUM_TOTAL_SIZE = (512 * 1024) };
 
 /* Size of buffer size to use while copying files.  */
-#define COPY_BUFFER_SIZE (32 * 512)
+enum { COPY_BUFFER_SIZE = (32 * 512) };
 
 /* Output functions.  Most of the complexity is for handling cpp like
    sync lines.
@@ -168,8 +168,8 @@ cleanup_tmpfile (void)
           if (!diversion->size && diversion->u.file
               && close_stream_temp (diversion->u.file) != 0)
             {
-              M4ERROR ((0, errno,
-                        _("cannot clean temporary file for diversion")));
+              M4ERROR(0, errno,
+                        _("cannot clean temporary file for diversion"));
               fail = true;
             }
         }
@@ -523,14 +523,6 @@ make_room_for (int length)
 | diversion file or an in-memory diversion buffer.              |
 `--------------------------------------------------------------*/
 
-#define OUTPUT_CHARACTER(Char) \
-  if (output_file)                                                      \
-    putc ((Char), output_file);                                         \
-  else if (output_unused == 0)                                          \
-    output_character_helper ((Char));                                   \
-  else                                                                  \
-    (output_unused--, *output_cursor++ = (Char))
-
 static void
 output_character_helper (int character)
 {
@@ -545,6 +537,15 @@ output_character_helper (int character)
     }
 }
 
+static void OUTPUT_CHARACTER(char Char) {
+  if (output_file)
+    putc((Char), output_file);
+  else if (output_unused == 0)
+    output_character_helper((Char));
+  else
+    (output_unused--, *output_cursor++ = (Char));
+}
+
 /*-------------------------------------------------------------------.
 | Output one TEXT having LENGTH characters, when it is known that it |
 | goes to a diversion file or an in-memory diversion buffer.         |
@@ -898,7 +899,7 @@ insert_diversion_helper (m4_diversion *diversion)
                       _("cannot clean temporary file for diversion"));
         }
       if (m4_tmpremove (diversion->divnum) != 0)
-        M4ERROR ((0, errno, _("cannot clean temporary file for diversion")));
+        M4ERROR(0, errno, _("cannot clean temporary file for diversion"));
     }
   diversion->used = 0;
   gl_oset_remove (diversion_table, diversion);
diff --git a/src/path.c b/src/path.c
index 71ccb3e..e2a8545 100644
--- a/src/path.c
+++ b/src/path.c
@@ -174,7 +174,7 @@ m4_path_search (const char *file, char **result)
       if (fp != NULL)
         {
           if (debug_level & DEBUG_TRACE_PATH)
-            DEBUG_MESSAGE2 ("path search for `%s' found `%s'", file, name);
+            DEBUG_MESSAGE2_str_str("path search for `%s' found `%s'", file, name);
           if (result)
             *result = name;
           else
diff --git a/src/symtab.c b/src/symtab.c
index c5a8564..cbad7ff 100644
--- a/src/symtab.c
+++ b/src/symtab.c
@@ -110,8 +110,8 @@ symtab_init (void)
   {
     int e = atexit(show_profile);
     if (e != 0)
-      M4ERROR ((warning_status, 0,
-                "INTERNAL ERROR: unable to show symtab profile"));
+      M4ERROR(warning_status, 0,
+                "INTERNAL ERROR: unable to show symtab profile");
   }
 #endif /* DEBUG_SYM */
 }
@@ -140,14 +140,14 @@ hash (const char *s)
 void
 free_symbol (symbol *sym)
 {
-  if (SYMBOL_PENDING_EXPANSIONS (sym) > 0)
-    SYMBOL_DELETED (sym) = true;
+  if ((*SYMBOL_PENDING_EXPANSIONS (sym)) > 0)
+    SYMBOL_DELETED_set(sym, true);
   else
     {
-      if (SYMBOL_STACK (sym) == NULL)
-        free (SYMBOL_NAME (sym));
-      if (SYMBOL_TYPE (sym) == TOKEN_TEXT)
-        free (SYMBOL_TEXT (sym));
+      if ((*SYMBOL_STACK (sym)) == NULL)
+        free (*SYMBOL_NAME (sym));
+      if (*SYMBOL_TYPE (sym) == TOKEN_TEXT)
+        free (*SYMBOL_TEXT (sym));
       free (sym);
     }
 }
@@ -185,7 +185,7 @@ lookup_symbol (const char *name, symbol_lookup mode)
     {
       cmp = (h > sym->hash) - (h < sym->hash);
       if (cmp == 0)
-        cmp = strcmp (SYMBOL_NAME (sym), name);
+        cmp = strcmp (*SYMBOL_NAME (sym), name);
       if (cmp >= 0)
         break;
     }
@@ -211,24 +211,24 @@ lookup_symbol (const char *name, symbol_lookup mode)
 
       if (cmp == 0 && sym != NULL)
         {
-          if (SYMBOL_PENDING_EXPANSIONS (sym) > 0)
+          if ((*SYMBOL_PENDING_EXPANSIONS (sym)) > 0)
             {
               symbol *old = sym;
-              SYMBOL_DELETED (old) = true;
+              SYMBOL_DELETED_set(old, true);
 
               sym = (symbol *) xmalloc (sizeof (symbol));
-              SYMBOL_TYPE (sym) = TOKEN_VOID;
-              SYMBOL_TRACED (sym) = SYMBOL_TRACED (old);
+              *SYMBOL_TYPE (sym) = TOKEN_VOID;
+              SYMBOL_TRACED_set(sym, SYMBOL_TRACED_get(old));
               sym->hash = h;
-              SYMBOL_NAME (sym) = old->name;
+              *SYMBOL_NAME (sym) = old->name;
               old->name = xstrdup (name);
-              SYMBOL_MACRO_ARGS (sym) = false;
-              SYMBOL_BLIND_NO_ARGS (sym) = false;
-              SYMBOL_DELETED (sym) = false;
-              SYMBOL_PENDING_EXPANSIONS (sym) = 0;
+              SYMBOL_MACRO_ARGS_set(sym, false);
+              SYMBOL_BLIND_NO_ARGS_set(sym, false);
+              SYMBOL_DELETED_set(sym, false);
+              (*SYMBOL_PENDING_EXPANSIONS (sym)) = 0;
 
-              SYMBOL_STACK (sym) = SYMBOL_STACK (old);
-              SYMBOL_STACK (old) = NULL;
+              (*SYMBOL_STACK (sym)) = *SYMBOL_STACK (old);
+              *SYMBOL_STACK (old) = NULL;
               sym->next = old->next;
               old->next = NULL;
               *spp = sym;
@@ -243,28 +243,28 @@ lookup_symbol (const char *name, symbol_lookup mode)
          with the name, insert this in front of it.  */
 
       sym = (symbol *) xmalloc (sizeof (symbol));
-      SYMBOL_TYPE (sym) = TOKEN_VOID;
-      SYMBOL_TRACED (sym) = false;
+      *SYMBOL_TYPE (sym) = TOKEN_VOID;
+      SYMBOL_TRACED_set(sym, false);
       sym->hash = h;
-      SYMBOL_MACRO_ARGS (sym) = false;
-      SYMBOL_BLIND_NO_ARGS (sym) = false;
-      SYMBOL_DELETED (sym) = false;
-      SYMBOL_PENDING_EXPANSIONS (sym) = 0;
+      SYMBOL_MACRO_ARGS_set(sym, false);
+      SYMBOL_BLIND_NO_ARGS_set(sym, false);
+      SYMBOL_DELETED_set(sym, false);
+      (*SYMBOL_PENDING_EXPANSIONS (sym)) = 0;
 
-      SYMBOL_STACK (sym) = NULL;
+      (*SYMBOL_STACK (sym)) = NULL;
       sym->next = *spp;
       *spp = sym;
 
       if (mode == SYMBOL_PUSHDEF && cmp == 0)
         {
-          SYMBOL_STACK (sym) = sym->next;
-          sym->next = SYMBOL_STACK (sym)->next;
-          SYMBOL_STACK (sym)->next = NULL;
-          SYMBOL_TRACED (sym) = SYMBOL_TRACED (SYMBOL_STACK (sym));
-          SYMBOL_NAME (sym) = SYMBOL_NAME (SYMBOL_STACK (sym));
+          (*SYMBOL_STACK (sym)) = sym->next;
+          sym->next = (*SYMBOL_STACK (sym))->next;
+          (*SYMBOL_STACK (sym))->next = NULL;
+          SYMBOL_TRACED_set(sym, SYMBOL_TRACED_get((*SYMBOL_STACK (sym))));
+          *SYMBOL_NAME (sym) = *SYMBOL_NAME ((*SYMBOL_STACK (sym)));
         }
       else
-        SYMBOL_NAME (sym) = xstrdup (name);
+        *SYMBOL_NAME (sym) = xstrdup (name);
       return sym;
 
     case SYMBOL_DELETE:
@@ -282,21 +282,21 @@ lookup_symbol (const char *name, symbol_lookup mode)
       {
         bool traced = false;
         symbol *next;
-        if (SYMBOL_STACK (sym) != NULL
+        if ((*SYMBOL_STACK (sym)) != NULL
             && mode == SYMBOL_POPDEF)
           {
-            SYMBOL_TRACED (SYMBOL_STACK (sym)) = SYMBOL_TRACED (sym);
-            SYMBOL_STACK (sym)->next = sym->next;
-            *spp = SYMBOL_STACK (sym);
+            SYMBOL_TRACED_set((*SYMBOL_STACK (sym)), SYMBOL_TRACED_get(sym));
+            (*SYMBOL_STACK (sym))->next = sym->next;
+            *spp = (*SYMBOL_STACK (sym));
           }
         else
           {
-            traced = SYMBOL_TRACED (sym);
+            traced = SYMBOL_TRACED_get(sym);
             *spp = sym->next;
           }
         do
           {
-            next = SYMBOL_STACK (sym);
+            next = (*SYMBOL_STACK (sym));
             free_symbol (sym);
             sym = next;
           }
@@ -304,16 +304,16 @@ lookup_symbol (const char *name, symbol_lookup mode)
         if (traced)
           {
             sym = (symbol *) xmalloc (sizeof (symbol));
-            SYMBOL_TYPE (sym) = TOKEN_VOID;
-            SYMBOL_TRACED (sym) = true;
+            *SYMBOL_TYPE (sym) = TOKEN_VOID;
+            SYMBOL_TRACED_set(sym, true);
             sym->hash = h;
-            SYMBOL_NAME (sym) = xstrdup (name);
-            SYMBOL_MACRO_ARGS (sym) = false;
-            SYMBOL_BLIND_NO_ARGS (sym) = false;
-            SYMBOL_DELETED (sym) = false;
-            SYMBOL_PENDING_EXPANSIONS (sym) = 0;
+            *SYMBOL_NAME (sym) = xstrdup (name);
+            SYMBOL_MACRO_ARGS_set(sym, false);
+            SYMBOL_BLIND_NO_ARGS_set(sym, false);
+            SYMBOL_DELETED_set(sym, false);
+            (*SYMBOL_PENDING_EXPANSIONS (sym)) = 0;
 
-            SYMBOL_STACK (sym) = NULL;
+            (*SYMBOL_STACK (sym)) = NULL;
             sym->next = *spp;
             *spp = sym;
           }
@@ -322,8 +322,8 @@ lookup_symbol (const char *name, symbol_lookup mode)
 
     case SYMBOL_LOOKUP:
     default:
-      M4ERROR ((warning_status, 0,
-                "INTERNAL ERROR: invalid mode to symbol_lookup ()"));
+      M4ERROR(warning_status, 0,
+                "INTERNAL ERROR: invalid mode to symbol_lookup ()");
       abort ();
     }
 }
@@ -374,7 +374,7 @@ symtab_debug (void)
 
   while (next_token (&td, NULL) == TOKEN_WORD)
     {
-      text = TOKEN_DATA_TEXT (&td);
+      text = *TOKEN_DATA_TEXT (&td);
       if (*text == '_')
         {
           delete = 1;
@@ -406,12 +406,12 @@ symtab_print_list (int i)
       for (sym = bucket; sym; sym = sym->stack)
         xprintf ("\tname %s, hash %lu, bucket %lu, addr %p, stack %p, "
                  "next %p, flags%s%s, pending %d\n",
-                 SYMBOL_NAME (sym), (unsigned long int) sym->hash,
-                 (unsigned long int) h, sym, SYMBOL_STACK (sym),
+                 *SYMBOL_NAME (sym), (unsigned long int) sym->hash,
+                 (unsigned long int) h, sym, (*SYMBOL_STACK (sym)),
                  sym->next,
-                 SYMBOL_TRACED (sym) ? " traced" : "",
-                 SYMBOL_DELETED (sym) ? " deleted" : "",
-                 SYMBOL_PENDING_EXPANSIONS (sym));
+                 SYMBOL_TRACED_get(sym) ? " traced" : "",
+                 SYMBOL_DELETED_get(sym) ? " deleted" : "",
+                 (*SYMBOL_PENDING_EXPANSIONS (sym)));
 }
 
 #endif /* DEBUG_SYM */
diff --git a/tests/Makefile.in b/tests/Makefile.in
index 64ce81c..53fd7a7 100644
--- a/tests/Makefile.in
+++ b/tests/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.16.3 from Makefile.am.
+# Makefile.in generated by automake 1.16.5 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2020 Free Software Foundation, Inc.
+# Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -2521,8 +2521,6 @@ am__define_uniq_tagged_files = \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
 am__tty_colors_dummy = \
   mgn= red= grn= lgn= blu= brg= std=; \
   am__color_tests=no
@@ -2783,6 +2781,8 @@ CFLAG_VISIBILITY = @CFLAG_VISIBILITY@
 CONFIG_INCLUDE = @CONFIG_INCLUDE@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CSCOPE = @CSCOPE@
+CTAGS = @CTAGS@
 CXX = @CXX@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
@@ -2801,6 +2801,7 @@ ENOLINK_VALUE = @ENOLINK_VALUE@
 EOVERFLOW_HIDDEN = @EOVERFLOW_HIDDEN@
 EOVERFLOW_VALUE = @EOVERFLOW_VALUE@
 ERRNO_H = @ERRNO_H@
+ETAGS = @ETAGS@
 EXEEXT = @EXEEXT@
 FLOAT_H = @FLOAT_H@
 GETOPT_CDEFS_H = @GETOPT_CDEFS_H@
@@ -8804,7 +8805,6 @@ test-xvasprintf.log: test-xvasprintf$(EXEEXT)
 @am__EXEEXT_TRUE@	--log-file $$b.log --trs-file $$b.trs \
 @am__EXEEXT_TRUE@	$(am__common_driver_flags) $(AM_TEST_LOG_DRIVER_FLAGS) $(TEST_LOG_DRIVER_FLAGS) -- $(TEST_LOG_COMPILE) \
 @am__EXEEXT_TRUE@	"$$tst" $(AM_TESTS_FD_REDIRECT)
-
 distdir: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) distdir-am
 
